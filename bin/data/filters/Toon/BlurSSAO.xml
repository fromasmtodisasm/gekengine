<?xml version="1.0"?>
<filter flipscreens="true">
    <defines>
        <define name="gs_nRadius" value="6" />
        <define name="gs_nGuassianDeviation" value="3" />
        <define name="gs_nScale" value="1" />
        <define name="gs_nEdgeSharpness" value="1" />
        <define name="gs_nEpsilon" value="0.0001" />
    </defines>

    <pixel>
        <resources>
            <resource stage="1" source="Toon.Albedo" />
            <resource stage="2" source="Toon.Depth" />
            <resource stage="3" source="screen" />
        </resources>
        
        <![CDATA[
            Texture2D           gs_pAlbedoBuffer        : register(t1);
            Texture2D<float>    gs_pDepthBuffer         : register(t2);
            Texture2D           gs_pScreenBuffer        : register(t3);

            static const float gs_aGuassian[][7] = 
            {
                { 0.356642, 0.239400, 0.072410, 0.009869, 0,        0,        0        },
                { 0.398943, 0.241971, 0.053991, 0.004432, 0.000134, 0,        0        }, // stddev = 1.0
                { 0.153170, 0.144893, 0.122649, 0.092902, 0.062970, 0,        0        }, // stddev = 2.0
                { 0.111220, 0.107798, 0.098151, 0.083953, 0.067458, 0.050920, 0.036108 }  // stddev = 3.0
            };
            
            float4 MainPixelProgram(INPUT kInput) : SV_TARGET
            {
                float2 nPixelSize;
                gs_pScreenBuffer.GetDimensions(nPixelSize.x, nPixelSize.y);
                nPixelSize = rcp(nPixelSize);                

	            float nCenterDepth = gs_pDepthBuffer.Sample(gs_pPointSampler, kInput.texcoord);
	            float4 nCenterColor = gs_pScreenBuffer.Sample(gs_pPointSampler, kInput.texcoord);

	            float nTotalWeight = gs_aGuassian[gs_nGuassianDeviation][0];
	            float nAmbientOcclusion = nCenterColor.a * nTotalWeight;

	            [unroll]
	            for (int nSample = -gs_nRadius; nSample <= gs_nRadius; ++nSample)
	            {
		            // We already handled the zero case above.  This loop should be unrolled and the branch discarded
		            if (nSample != 0)
		            {
			            float2 nSampleCoord = kInput.texcoord + gs_nAxis * (nSample * nPixelSize * gs_nScale);
			            float nSampleDepth = gs_pDepthBuffer.Sample(gs_pPointSampler, nSampleCoord);
			            float nSampleAmbient = gs_pScreenBuffer.Sample(gs_pPointSampler, nSampleCoord).a;

			            // spatial domain: offset gaussian tap
			            float nWeight = gs_aGuassian[gs_nGuassianDeviation][abs(nSample)];

			            // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
			            nWeight *= rcp(gs_nEpsilon + gs_nEdgeSharpness * abs(nCenterDepth - nSampleDepth));

			            nAmbientOcclusion += nSampleAmbient * nWeight;
			            nTotalWeight += nWeight;
		            }
	            }

                nAmbientOcclusion = (nAmbientOcclusion / (nTotalWeight + gs_nEpsilon));
                if(gs_bCombine)
                {
                    float4 nAlbedo = gs_pAlbedoBuffer.Sample(gs_pPointSampler, kInput.texcoord);
                    
                    [branch]
                    if(nAlbedo.a == 1)
                    {
	                    return float4(nCenterColor.xyz, 0);
                    }
                    else
                    {
	                    return float4(nCenterColor.xyz * nAmbientOcclusion, 0);
                    }
                }
                else
                {
	                return float4(nCenterColor.xyz, nAmbientOcclusion);
                }
            }
        ]]>
    </pixel>
</filter>
