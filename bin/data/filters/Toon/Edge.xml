<?xml version="1.0"?>
<filter>
    <defines>
        <define name="gs_nRadius" value="3" />
    </defines>

    <pixel>
        <resources>
            <resource stage="0" source="Toon/Deferred.Albedo" />
            <resource stage="1" source="Toon/Deferred.World" />
        </resources>
        
        <![CDATA[
            Texture2D     gs_pAlbedoBuffer          : register(t0);
            Texture2D     gs_pWorldBuffer           : register(t1);

            float4 MainPixelProgram(INPUT kInput) : SV_TARGET
            {
                float2 nInverseCameraSize = (rcp(gs_nCameraSize) * gs_nRadius);
                float nInverseCameraViewDistance = rcp(gs_nCameraViewDistance);
	            float4 nCenter = gs_pWorldBuffer.Sample(gs_pPointSampler, kInput.texcoord) * float4(1,1,1,nInverseCameraViewDistance);
                float4 nPointP0 = gs_pWorldBuffer.Sample(gs_pPointSampler, (kInput.texcoord + float2( nInverseCameraSize.x, 0.0f))) * float4(1,1,1,nInverseCameraViewDistance);
                float4 nPointN0 = gs_pWorldBuffer.Sample(gs_pPointSampler, (kInput.texcoord + float2(-nInverseCameraSize.x, 0.0f))) * float4(1,1,1,nInverseCameraViewDistance);
                float4 nPoint0P = gs_pWorldBuffer.Sample(gs_pPointSampler, (kInput.texcoord + float2( 0.0f, nInverseCameraSize.y))) * float4(1,1,1,nInverseCameraViewDistance);
                float4 nPoint0N = gs_pWorldBuffer.Sample(gs_pPointSampler, (kInput.texcoord + float2( 0.0f,-nInverseCameraSize.y))) * float4(1,1,1,nInverseCameraViewDistance);
                float4 nPointNN = gs_pWorldBuffer.Sample(gs_pPointSampler, (kInput.texcoord + float2(-nInverseCameraSize.x,-nInverseCameraSize.y))) * float4(1,1,1,nInverseCameraViewDistance);
                float4 nPointPP = gs_pWorldBuffer.Sample(gs_pPointSampler, (kInput.texcoord + float2( nInverseCameraSize.x, nInverseCameraSize.y))) * float4(1,1,1,nInverseCameraViewDistance);
                float4 nPointNP = gs_pWorldBuffer.Sample(gs_pPointSampler, (kInput.texcoord + float2(-nInverseCameraSize.x, nInverseCameraSize.y))) * float4(1,1,1,nInverseCameraViewDistance);
                float4 nPointPN = gs_pWorldBuffer.Sample(gs_pPointSampler, (kInput.texcoord + float2( nInverseCameraSize.x,-nInverseCameraSize.y))) * float4(1,1,1,nInverseCameraViewDistance);

                float4 nEdgeNormal;
                nEdgeNormal.x = dot(nPointP0.xyz, nPointN0.xyz);
                nEdgeNormal.y = dot(nPoint0P.xyz, nPoint0N.xyz);
                nEdgeNormal.z = dot(nPointNN.xyz, nPointPP.xyz);
                nEdgeNormal.w = dot(nPointNP.xyz, nPointPN.xyz);
                nEdgeNormal -= 0.7f;
                nEdgeNormal = step(0, nEdgeNormal);
                float nAverageEdgeNormal = saturate(dot(nEdgeNormal, 0.3f));
 
                float4 nEdgeDepth;
                nEdgeDepth.x = (nPointP0.w + nPointN0.w);
                nEdgeDepth.y = (nPoint0P.w + nPoint0N.w);
                nEdgeDepth.z = (nPointNN.w + nPointPP.w);
                nEdgeDepth.w = (nPointNP.w + nPointPN.w);
                nEdgeDepth = (abs((2.0f * nCenter.w) - nEdgeDepth) - 0.001f);
                nEdgeDepth = step(nEdgeDepth, 0);
                float nAverageEdgeDepth = saturate(dot(nEdgeDepth, 0.4f));

                float4 nAlbedo = gs_pAlbedoBuffer.Sample(gs_pPointSampler, kInput.texcoord);

                return nAverageEdgeNormal * nAverageEdgeDepth;
                //return float4((nAlbedo.xyz * nAverageEdgeDepth * nAverageEdgeNormal), 1.0f);
            }
        ]]>
    </pixel>
</filter>
