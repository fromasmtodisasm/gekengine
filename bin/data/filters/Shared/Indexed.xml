<![CDATA[
    Texture2D<float4> gs_pWorldBuffer       : register(t1);

    RWBuffer<uint> g_pTileOutput            : register(u0);

    groupshared uint g_nTileMinDepth;
    groupshared uint g_nTileMaxDepth;
    groupshared uint g_nNumTileLights;
    groupshared uint g_aTileLightList[gs_nMaxLights];
    groupshared float4 g_aTileFrustum[6];

    [numthreads(gs_nLightTileSize, gs_nLightTileSize, 1)]
    void MainComputeProgram(uint3 nScreenPixel : SV_DispatchThreadID, uint3 nTileID : SV_GroupID, uint3 nTilePixelID : SV_GroupThreadID, uint nTilePixelIndex : SV_GroupIndex)
    {
        [branch]
        if(nTilePixelIndex == 0)
        {
            g_nNumTileLights = 0;
            g_nTileMinDepth = 0x7F7FFFFF;
            g_nTileMaxDepth = 0;
        }

        float nViewDepth = gs_pWorldBuffer[nScreenPixel.xy].w;
        uint nViewDepthInt = asuint(nViewDepth);

        GroupMemoryBarrierWithGroupSync();

        InterlockedMin(g_nTileMinDepth, nViewDepthInt);
        InterlockedMax(g_nTileMaxDepth, nViewDepthInt);

        GroupMemoryBarrierWithGroupSync();

        float nMinTileDepth = asfloat(g_nTileMinDepth);
        float nMaxTileDepth = asfloat(g_nTileMaxDepth);

        [branch]
        if(nTilePixelIndex == 0)
        {
            float2 nTileScale = gs_nCameraSize * rcp(float(2*gs_nLightTileSize));
            float2 nTileBias = nTileScale - float2(nTileID.xy);

            float3 nXPlane = float3(gs_nProjectionMatrix[0][0] * nTileScale.x, 0.0f, nTileBias.x);
            float3 nYPlane = float3(0.0f, -gs_nProjectionMatrix[1][1] * nTileScale.y, nTileBias.y);
            float3 nZPlane = float3(0.0f, 0.0f, 1.0f);

            g_aTileFrustum[0] = float4(normalize(nZPlane - nXPlane), 0.0f),
            g_aTileFrustum[1] = float4(normalize(nZPlane + nXPlane), 0.0f),
            g_aTileFrustum[2] = float4(normalize(nZPlane - nYPlane), 0.0f),
            g_aTileFrustum[3] = float4(normalize(nZPlane + nYPlane), 0.0f),
            g_aTileFrustum[4] = float4(0.0f, 0.0f,  1.0f, -nMinTileDepth);
            g_aTileFrustum[5] = float4(0.0f, 0.0f, -1.0f,  nMaxTileDepth);
        }

        GroupMemoryBarrierWithGroupSync();

        [loop]
        for(uint nLight = nTilePixelIndex; nLight < gs_nMaxLights; nLight += (gs_nLightTileSize * gs_nLightTileSize))
        {
            [branch]
            if(gs_aLights[nLight].m_nRange <= 0.0f)
            {
                break;
            }

            bool bIsLightInFrustum = true;

            [unroll]
            for (uint nIndex = 0; nIndex < 6; ++nIndex)
            {
                float nDistance = dot(g_aTileFrustum[nIndex], float4(gs_aLights[nLight].m_nPosition, 1.0f));
                bIsLightInFrustum = (bIsLightInFrustum && (nDistance >= -gs_aLights[nLight].m_nRange));
            }

            [branch]
            if (bIsLightInFrustum)
            {
                uint nTileIndex;
                InterlockedAdd(g_nNumTileLights, 1, nTileIndex);
                g_aTileLightList[nTileIndex] = nLight;
            }
        }

        GroupMemoryBarrierWithGroupSync();
        
        [branch]
        if(nTilePixelIndex < gs_nMaxLights)
        {
            uint nTileIndex = ((nTileID.y * gs_nDispatchXSize) + nTileID.x);
            uint nBufferIndex = ((nTileIndex * gs_nMaxLights) + nTilePixelIndex);
            uint nLightIndex = (nTilePixelIndex < g_nNumTileLights ? g_aTileLightList[nTilePixelIndex] : gs_nMaxLights);
            //g_pTileOutput[nBufferIndex] = nLightIndex;
            g_pTileOutput[nBufferIndex] = g_nNumTileLights / float(gs_nMaxLights) * 255.0f;
            //g_pTileOutput[nBufferIndex] = nMinTileDepth / gs_nCameraViewDistance * 255.0f;
        }
    }
]]>