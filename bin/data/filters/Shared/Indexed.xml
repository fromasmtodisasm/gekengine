<![CDATA[
    Texture2D<float4> gs_pWorldBuffer       : register(t1);

    RWBuffer<uint> g_pTileOutput            : register(u0);

    groupshared uint g_nNumTileLights;
    groupshared uint g_nTileMinDepth;
    groupshared uint g_nTileMaxDepth;
    groupshared uint g_aTileLightList[gs_nMaxLights];

    [numthreads(gs_nLightTileSize, gs_nLightTileSize, 1)]
    void MainComputeProgram(uint3 nScreenPixel : SV_DispatchThreadID, uint3 nTileID : SV_GroupID, uint3 nTilePixelID : SV_GroupThreadID, uint nTilePixelIndex : SV_GroupIndex)
    {
        [branch]
        if(nTilePixelIndex == 0)
        {
            g_nNumTileLights = 0;
            g_nTileMinDepth = 0x7f7fffff;
            g_nTileMaxDepth = 0;
        }

        float nMinSampleDepth = gs_nCameraViewDistance;
        float nMaxSampleDepth = 0.0f;

        float nViewDepth = gs_pWorldBuffer[nScreenPixel.xy].w;
        nMinSampleDepth = min(nMinSampleDepth, nViewDepth);
        nMaxSampleDepth = max(nMaxSampleDepth, nViewDepth);

        GroupMemoryBarrierWithGroupSync();

        if (nMaxSampleDepth >= nMinSampleDepth)
        {
            InterlockedMin(g_nTileMinDepth, asuint(nMinSampleDepth));
            InterlockedMax(g_nTileMaxDepth, asuint(nMaxSampleDepth));
        }

        GroupMemoryBarrierWithGroupSync();

        float nMinTileDepth = asfloat(g_nTileMinDepth);
        float nMaxTileDepth = asfloat(g_nTileMaxDepth);

        float2 nTileScale = gs_nCameraSize * rcp(float(2*gs_nLightTileSize));
        float2 nTileBias = nTileScale - float2(nTileID.xy);

        float4 c1 = float4(gs_nProjectionMatrix[0][0] * nTileScale.x, 0.0f, nTileBias.x, 0.0f);
        float4 c2 = float4(0.0f, -gs_nProjectionMatrix[1][1] * nTileScale.y, nTileBias.y, 0.0f);
        float4 c4 = float4(0.0f, 0.0f, 1.0f, 0.0f);

        float4 aFrustumPlanes[6] = 
        {
            c4 - c1,
            c4 + c1,
            c4 - c2,
            c4 + c2,
            float4(0.0f, 0.0f,  1.0f, -nMinTileDepth),
            float4(0.0f, 0.0f, -1.0f,  nMaxTileDepth),
        };

        [loop]
        for(uint nPlane = 0; nPlane < 4; nPlane++)
        {
            aFrustumPlanes[nPlane] *= rcp(length(aFrustumPlanes[nPlane].xyz));
        }

        [loop]
        for(uint nLight = nTilePixelIndex; nLight < gs_nMaxLights; nLight += (gs_nLightTileSize * gs_nLightTileSize))
        {
            LIGHT kLight = gs_aLights[nLight];

            [branch]
            if(kLight.m_nRange > 0.0f)
            {
                bool bIsLightInFrustum = true;

                [unroll]
                for (uint nIndex = 0; nIndex < 6; ++nIndex)
                {
                    float nDistance = dot(aFrustumPlanes[nIndex], float4(kLight.m_nPosition, 1.0f));
                    bIsLightInFrustum = (bIsLightInFrustum && (nDistance >= -kLight.m_nRange));
                }

                [branch]
                if (bIsLightInFrustum)
                {
                    uint nTileIndex;
                    InterlockedAdd(g_nNumTileLights, 1, nTileIndex);
                    g_aTileLightList[nTileIndex] = nLight;
                }
            }
        }

        GroupMemoryBarrierWithGroupSync();
        
        [branch]
        if(nTilePixelIndex < gs_nMaxLights)
        {
            uint nTileIndex = ((nTileID.y * gs_nDispatchXSize) + nTileID.x);
            uint nBufferIndex = ((nTileIndex * gs_nMaxLights) + nTilePixelIndex);
            uint nLightIndex = (nTilePixelIndex < g_nNumTileLights ? g_aTileLightList[nTilePixelIndex] : gs_nMaxLights);
            g_pTileOutput[nBufferIndex] = nLightIndex;//g_nNumTileLights / float(gs_nMaxLights) * 255.0f;
        }
    }
]]>