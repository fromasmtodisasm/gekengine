<![CDATA[
    #define gs_nThreadGroupSize             (gs_nLightTileSize * gs_nLightTileSize)

    Texture2D<float4> gs_pWorldBuffer       : register(t1);

    RWBuffer<uint> g_pTileOutput            : register(u0);

    groupshared uint g_nNumTileLights;
    groupshared uint g_nTileMinDepth;
    groupshared uint g_nTileMaxDepth;
    groupshared uint g_aTileLightList[gs_nMaxLights];

    [numthreads(gs_nLightTileSize, gs_nLightTileSize, 1)]
    void MainComputeProgram(uint3 nScreenPixel : SV_DispatchThreadID, uint3 nTileID : SV_GroupID, uint3 nTilePixelID : SV_GroupThreadID, uint nTilePixelIndex : SV_GroupIndex)
    {
        [branch]
        if(nTilePixelIndex == 0)
        {
            g_nNumTileLights = 0;
            g_nTileMinDepth = 0x7f7fffff;
            g_nTileMaxDepth = 0;
        }

        float nMinSampleDepth = gs_nCameraViewDistance;
        float nMaxSampleDepth = 0.0f;

        float4 nWorld = gs_pWorldBuffer[nScreenPixel.xy];
        float nViewDepth = gs_pWorldBuffer[nScreenPixel.xy].w;
        float nLinearDepth = (gs_nProjectionMatrix._43 / (nViewDepth - gs_nProjectionMatrix._33));
        nMinSampleDepth = min(nMinSampleDepth, nLinearDepth);
        nMaxSampleDepth = max(nMaxSampleDepth, nLinearDepth);

        GroupMemoryBarrierWithGroupSync();

        if (nMaxSampleDepth >= nMinSampleDepth)
        {
            InterlockedMin(g_nTileMinDepth, asuint(nMinSampleDepth));
            InterlockedMax(g_nTileMaxDepth, asuint(nMaxSampleDepth));
        }

        GroupMemoryBarrierWithGroupSync();

        float nMinTileDepth = asfloat(g_nTileMinDepth);
        float nMaxTileDepth = asfloat(g_nTileMaxDepth);
        float2 nTileScale = (gs_nCameraSize.xy * rcp(2.0f * gs_nLightTileSize.xx));
        float2 nTileBias = (nTileScale - float2(nTileID.xy));
        float4 nXPlane = float4((gs_nProjectionMatrix._11 * nTileScale.x), 0.0f, nTileBias.x, 0.0f);
        float4 nYPlane = float4(0.0f, (-gs_nProjectionMatrix._22 * nTileScale.y), nTileBias.y, 0.0f);
        float4 nZPlane = float4(0.0f, 0.0f, 1.0f, 0.0f);
        float4 aFrustumPlanes[6] = 
        {
            // Sides
            (nZPlane - nXPlane),
            (nZPlane + nXPlane),
            (nZPlane - nYPlane),
            (nZPlane + nYPlane),

            // Near/far
            float4(0.0f, 0.0f, 1.0f, -nMinTileDepth),
            float4(0.0f, 0.0f, -1.0f, nMaxTileDepth),
        };

        [unroll]
        for (uint nIndex = 0; nIndex < 4; ++nIndex)
        {
            aFrustumPlanes[nIndex] *= rcp(length(aFrustumPlanes[nIndex].xyz));
        }

        [loop]
        for(uint nLight = nTilePixelIndex; nLight < gs_nMaxLights && gs_aLights[nLight].m_nRange > 0.0f; nLight += gs_nThreadGroupSize)
        {
            float3 nLightPosition = gs_aLights[nLight].m_nPosition;
            float nLightRange = gs_aLights[nLight].m_nRange;
            bool bIsLightInFrustum = true;

            [unroll]
            for (uint nIndex = 0; nIndex < 6; ++nIndex)
            {
                float nDistance = dot(aFrustumPlanes[nIndex], float4(nLightPosition, 1.0f));
                bIsLightInFrustum = (bIsLightInFrustum && (nDistance >= -nLightRange));
            }

            [branch]
            if (bIsLightInFrustum)
            {
                uint nTileIndex;
                InterlockedAdd(g_nNumTileLights, 1, nTileIndex);
                g_aTileLightList[nTileIndex] = nLight;
            }
        }

        GroupMemoryBarrierWithGroupSync();
        
        [branch]
        if(nTilePixelIndex < gs_nMaxLights)
        {
            uint nTileIndex = ((nTileID.y * gs_nDispatchXSize) + nTileID.x);
            uint nBufferIndex = ((nTileIndex * gs_nMaxLights) + nTilePixelIndex);
            uint nLightIndex = (nTilePixelIndex < g_nNumTileLights ? g_aTileLightList[nTilePixelIndex] : gs_nMaxLights);
            g_pTileOutput[nBufferIndex] = nLightIndex;
        }
    }
]]>