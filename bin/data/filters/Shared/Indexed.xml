<![CDATA[
    static const uint gs_nThreadGroupSize = gs_nLightTileSize * gs_nLightTileSize;
    static const uint2 gs_nNumTiles = asuint(ceil(gs_nCameraSize / gs_nLightTileSize));

    Texture2D<float4> gs_pWorldBuffer       : register(t1);

    RWBuffer<uint> g_pTileOutput            : register(u0);

    groupshared uint g_nNumTileLights = 0;
    groupshared uint g_nTileMinDepth = 0x7f7fffff;
    groupshared uint g_nTileMaxDepth = 0;
    groupshared uint g_aTileLightList[gs_nMaxLights];

    float LinearDepth(in float nViewDepth)
    {
        return gs_nProjectionMatrix._43 / (nViewDepth - gs_nProjectionMatrix._33);
    }

    [numthreads(gs_nLightTileSize, gs_nLightTileSize, 1)]
    void MainComputeProgram(uint3 nGroupID : SV_GroupID, uint3 nGroupThreadID : SV_GroupThreadID)
    {
        uint2 nPixelCoord = nGroupID.xy * gs_nLightTileSize + nGroupThreadID.xy;
        const uint nGroupThreadIndex = nGroupThreadID.y * gs_nLightTileSize + nGroupThreadID.x;

        float nMinSampleDepth = gs_nCameraViewDistance;
        float nMaxSampleDepth = 0.0f;

        float nViewDepth = gs_pWorldBuffer[nPixelCoord].w;
        float nLinearDepth = LinearDepth(nViewDepth);
        nMinSampleDepth = min(nMinSampleDepth, nLinearDepth);
        nMaxSampleDepth = max(nMaxSampleDepth, nLinearDepth);
        if (nMaxSampleDepth >= nMinSampleDepth)
        {
            InterlockedMin(g_nTileMinDepth, asuint(nMinSampleDepth));
            InterlockedMax(g_nTileMaxDepth, asuint(nMaxSampleDepth));
        }

        GroupMemoryBarrierWithGroupSync();
        float nMinTileDepth = asfloat(g_nTileMinDepth);
        float nMaxTileDepth = asfloat(g_nTileMaxDepth);
        float2 nTileScale = float2(gs_nCameraSize.xy) * rcp(2.0f * gs_nLightTileSize);
        float2 nTileBias = nTileScale - float2(nGroupID.xy);
        float4 c1 = float4(gs_nProjectionMatrix._11 * nTileScale.x, 0.0f, nTileBias.x, 0.0f);
        float4 c2 = float4(0.0f, -gs_nProjectionMatrix._22 * nTileScale.y, nTileBias.y, 0.0f);
        float4 c4 = float4(0.0f, 0.0f, 1.0f, 0.0f);
        float4 aFrustumPlanes[6] = 
        {
            // Sides
            c4 - c1,
            c4 + c1,
            c4 - c2,
            c4 + c2,

            // Near/far
            float4(0.0f, 0.0f, 1.0f, -nMinTileDepth),
            float4(0.0f, 0.0f, -1.0f, nMaxTileDepth),
        };

        [unroll]
        for (uint nIndex = 0; nIndex < 4; ++nIndex)
        {
            aFrustumPlanes[nIndex] *= rcp(length(aFrustumPlanes[nIndex].xyz));
        }

        [loop]
        for(uint nLight = nGroupThreadIndex; nLight < gs_nMaxLights && gs_aLights[nLight].m_nRange > 0.0f; nLight += gs_nThreadGroupSize)
        {
            float3 nLightPosition = gs_aLights[nLight].m_nPosition;
            float nLightRange = gs_aLights[nLight].m_nRange;

            bool bIsLightInFrustum = true;
/*
            [unroll]
            for (uint nIndex = 0; nIndex < 6; ++nIndex)
            {
                float nDistance = dot(aFrustumPlanes[nIndex], float4(nLightPosition, 1.0f));
                bIsLightInFrustum = bIsLightInFrustum && (nDistance >= -nLightRange);
            }
*/
            [branch]
            if (bIsLightInFrustum)
            {
                uint nTileIndex;
                InterlockedAdd(g_nNumTileLights, 1, nTileIndex);
                g_aTileLightList[nTileIndex] = nLight;
            }
        }

        GroupMemoryBarrierWithGroupSync();
        uint nTileIndex = nGroupID.y * gs_nNumTiles.x + nGroupID.x;
        uint nBufferIndex = nTileIndex * gs_nMaxLights + nGroupThreadIndex;
        uint nLightIndex = nGroupThreadIndex < g_nNumTileLights ? g_aTileLightList[nGroupThreadIndex] : gs_nMaxLights;
        g_pTileOutput[nBufferIndex] = g_nNumTileLights;
    }
]]>