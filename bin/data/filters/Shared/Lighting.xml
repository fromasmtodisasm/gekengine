<![CDATA[
    Texture2D     gs_pAlbedoBuffer          : register(t0);
    Texture2D     gs_pWorldBuffer           : register(t1);
    Texture2D     gs_pInfoBuffer            : register(t2);

    struct LIGHT
    {
        float4 m_nPosition;
        float3 m_nColor;
        float  m_nRange;
    };
    
    StructuredBuffer<LIGHT> gs_aLights      : register(t3);
    
    // Diffuse & Specular Term
    // http://www.gamedev.net/topic/639226-your-preferred-or-desired-brdf/
    void GetBRDF(out float3 nFinalDiffuse, out float3 nFinalSpecular, float4 nAlbedo, float3 nPixelNormal, float3 nLightNormal, float3 nViewNormal, float4 nInfo)
    {
        const float gs_nPI = 3.14159265358979323846;
        const float gs_nReciprocalPI = (1.0f / gs_nPI);

        float nRoughness = (nInfo.x * nInfo.x * 4);
        float nRoughnessSquared = (nRoughness * nRoughness);
        float nSpecular = nInfo.y;
        float nMetalness = nInfo.z;

        float3 Ks = lerp(nSpecular, nAlbedo.xyz, nMetalness);
        float3 Kd = lerp(nAlbedo.xyz, 0, nMetalness);
        float3 Fd = 1.0 - Ks;

        float nNormalViewAngle = dot(nPixelNormal, nViewNormal);
        float nNormalViewAngleSquared = (nNormalViewAngle * nNormalViewAngle);
        float nInvNormalViewAngleSquared = (1.0 - nNormalViewAngleSquared);

        float3 nHalfVector = normalize(nLightNormal + nViewNormal);
        float nNormalLightAngle = saturate(dot(nPixelNormal, nLightNormal));
        float nNormalHalfAngle = saturate(dot(nPixelNormal, nHalfVector));
        float nLightHalfAngle = saturate(dot(nLightNormal, nHalfVector));

        float nNormalLightAngleSquared = (nNormalLightAngle * nNormalLightAngle);
        float nNormalHalfAngleSquared = (nNormalHalfAngle * nNormalHalfAngle);
        float nInvNormalLightAngleSquared = (1.0 - nNormalLightAngleSquared);

        nFinalDiffuse = (Kd * Fd * gs_nReciprocalPI * saturate((1 - nRoughness) * 0.5 + 0.5 + nRoughnessSquared * (8 - nRoughness) * 0.023));

        float3 D = (pow(nRoughness/(nNormalHalfAngleSquared * (nRoughnessSquared + (1 - nNormalHalfAngleSquared) / nNormalHalfAngleSquared)), 2) / gs_nPI);

        float nIntensity = nNormalLightAngle;
        nNormalViewAngle = (nNormalViewAngle * 0.5 + 0.5);
        nNormalLightAngle = (nNormalLightAngle * 0.5 + 0.5);
        nNormalLightAngleSquared = (nNormalLightAngle * nNormalLightAngle);
        nNormalViewAngleSquared = (nNormalViewAngle * nNormalViewAngle);
        nInvNormalLightAngleSquared = (1.0 - nNormalLightAngleSquared);
        nInvNormalViewAngleSquared = (1.0 - nNormalViewAngleSquared);

        float nDiffuseDelta = lerp((1 / (0.1 + nRoughness)), (-nRoughnessSquared * 2), saturate(nRoughness));
        float nDiffuseLightAngle = (1 - (pow(1 - nNormalLightAngle, 4) * nDiffuseDelta));
        float nDiffuseViewAngle = (1 - (pow(1 - nNormalViewAngle, 4) * nDiffuseDelta));
        nFinalDiffuse *= (nDiffuseLightAngle * nDiffuseViewAngle * nIntensity);

        float3 Fs = (Ks + Fd * pow((1 - nLightHalfAngle), 5));

        nFinalSpecular = (Fs * D * nIntensity);
    }
    
    void GetLightingContribution(INPUT kInput, out float3 nTotalDiffuse, out float3 nTotalSpecular)
    {
        float4 nAlbedo = gs_pAlbedoBuffer.Sample(gs_pPointSampler, kInput.texcoord);

        float4 nPixelInfo = gs_pInfoBuffer.Sample(gs_pPointSampler, kInput.texcoord);

	    float4 nWorld = gs_pWorldBuffer.Sample(gs_pPointSampler, kInput.texcoord);
        float nPixelDepth = nWorld.w;
        float3 nPixelPosition = (nPixelDepth * kInput.view);
	    float3 nPixelNormal = nWorld.xyz;

        float3 nViewNormal = -kInput.view;

        float3 nTotalContribution = 0.0f;
        for(uint nLight = 0; gs_aLights[nLight].m_nRange > 0.0f; nLight++)
        {
            float3 nLightVector = (gs_aLights[nLight].m_nPosition.xyz - nPixelPosition);
            float nDistance = length(nLightVector);
            float3 nLightNormal = normalize(nLightVector);
	
            float nAttenuation = (1.0f - saturate(nDistance / gs_aLights[nLight].m_nRange));
            if(nAttenuation > 0.0f)
            {
                float3 nFinalDiffuse = 0.0f;
                float3 nFinalSpecular = 0.0f;
                GetBRDF(nFinalDiffuse, nFinalSpecular, nAlbedo, nPixelNormal, nLightNormal, nViewNormal, nPixelInfo);
                nTotalDiffuse += saturate(gs_aLights[nLight].m_nColor * nFinalDiffuse * nAttenuation);
                nTotalSpecular += saturate(gs_aLights[nLight].m_nColor * nFinalSpecular * nAttenuation);
            }
        }

        nTotalDiffuse = saturate(nTotalDiffuse);
        nTotalSpecular = saturate(nTotalSpecular);
    }
]]>
