<![CDATA[
    Texture2D     gs_pWorldBuffer           : register(t0);
    Texture2D     gs_pInfoBuffer            : register(t1); // Roughness, Specular, Height, 0

    struct LIGHT
    {
        float4 m_nPosition;
        float3 m_nColor;
        float m_nRange;
    };
    
    cbuffer LIGHTBUFFER                     : register(b1)
    {
        uint  gs_nNumLights;
        uint  gs_nBuffer[3];
        LIGHT gs_aLights[10];
    }
    
    struct OUTPUT
    {
        float4 diffuse                      : SV_TARGET0;
        float4 specular                     : SV_TARGET1;
    };

    // Diffuse & Specular Term
    // http://www.gamedev.net/topic/639226-your-preferred-or-desired-brdf/
    float2 GetBRDF(float3 nPixelNormal, float3 nLightNormal, float3 nViewNormal, float4 nInfo)
    {
        const float gs_nPI = 3.14159265358979323846;
        const float gs_nReciprocalPI = (1.0f / gs_nPI);

        float nColor = 1;
        float nRoughness = nInfo.x;
        float nSpecular = nInfo.y;
        float nRetroflective = 0;

        float nMetalness = saturate(nSpecular * 2 - 1);
        float nNonMetallicSpecular = (saturate(nSpecular * 2) * 0.2);

        float Ks = lerp(nNonMetallicSpecular, nColor, nMetalness);
        float Kd = lerp(nColor, 0, nMetalness);
        float Fd = 1.0 - Ks;

        float nNormalViewAngle = dot(nPixelNormal, nViewNormal);
        float nNormalViewAngleSquared = (nNormalViewAngle * nNormalViewAngle);
        float nInvNormalViewAngleSquared = (1.0 - nNormalViewAngleSquared);

        float nRoughnessMod = nRoughness;
        nRoughnessMod = (nRoughnessMod * nRoughnessMod * 4);
        float nRoughnessModSquared = (nRoughnessMod * nRoughnessMod);

        float3 nHalfVector = normalize(nLightNormal + nViewNormal);
        float nNormalLightAngle = saturate(dot(nPixelNormal, nLightNormal));
        float nNormalHalfAngle = saturate(dot(nPixelNormal, nHalfVector));
        float nLightHalfAngle = saturate(dot(nLightNormal, nHalfVector));

        float LdotV = dot(nLightNormal, nViewNormal);
        nNormalHalfAngle = lerp(nNormalHalfAngle,  LdotV, saturate(nRetroflective));

        float nNormalLightAngleSquared = (nNormalLightAngle * nNormalLightAngle);
        float nNormalHalfAngleSquared = (nNormalHalfAngle * nNormalHalfAngle);
        float nInvNormalLightAngleSquared = (1.0 - nNormalLightAngleSquared);

        float nFinalDiffuse = (Kd * Fd * gs_nReciprocalPI * saturate((1 - nRoughnessMod) * 0.5 + 0.5 + nRoughnessModSquared * (8 - nRoughnessMod) * 0.023));

        float D = (pow(nRoughnessMod/(nNormalHalfAngleSquared * (nRoughnessModSquared + (1 - nNormalHalfAngleSquared) / nNormalHalfAngleSquared)), 2) / gs_nPI);

        nNormalViewAngle = (nNormalViewAngle * 0.5 + 0.5);
        nNormalLightAngle = (nNormalLightAngle * 0.5 + 0.5);
        nNormalLightAngleSquared = (nNormalLightAngle * nNormalLightAngle);
        nNormalViewAngleSquared = (nNormalViewAngle * nNormalViewAngle);
        nInvNormalLightAngleSquared = (1.0 - nNormalLightAngleSquared);
        nInvNormalViewAngleSquared = (1.0 - nNormalViewAngleSquared);

        float nDiffuseDelta = lerp((1 / (0.1 + nRoughnessMod)), (-nRoughnessModSquared * 2), saturate(nRoughnessMod));
        float nDiffuseLightAngle = (1 - (pow(1 - nNormalLightAngle, 4) * nDiffuseDelta));
        float nDiffuseViewAngle = (1 - (pow(1 - nNormalViewAngle, 4) * nDiffuseDelta));
        nFinalDiffuse *= (nDiffuseLightAngle * nDiffuseViewAngle);

        float Fs = (Ks + Fd * pow((1 - nLightHalfAngle), 5));

        float nGeometric1 = (1.0 + sqrt(1.0 + nRoughnessModSquared * (nInvNormalLightAngleSquared / nNormalLightAngleSquared)));
        float nGeometric2 = (1.0 + sqrt(1.0 + nRoughnessModSquared * (nInvNormalViewAngleSquared / nNormalViewAngleSquared)));
        float nGeometric = (((2 / nGeometric1) * (2 / nGeometric2)) / (4 * nNormalViewAngle * nNormalLightAngle + 0.1));

        float nGeometricRetroreflective = (nNormalViewAngleSquared * nNormalLightAngle);
        nGeometric = lerp(nGeometric, nGeometricRetroreflective, nRetroflective);

        float nFinalSpecular = (Fs * D * nGeometric);

        return (float2(nFinalDiffuse, nFinalSpecular) * saturate(dot(nPixelNormal, nLightNormal)));
    }
    
    OUTPUT MainPixelProgram(INPUT kInput)
    {
        float3 nViewNormal = -kInput.view;

        float4 nPixelInfo = gs_pInfoBuffer.Sample(gs_pPointSampler, kInput.texcoord);

	    float4 nWorld = gs_pWorldBuffer.Sample(gs_pPointSampler, kInput.texcoord);
        float nPixelDepth = nWorld.w;
        float3 nPixelPosition = (nPixelDepth * kInput.view);
	    float3 nPixelNormal = nWorld.xyz;

        OUTPUT kOutput = (OUTPUT)0;
        for(uint nLight = 0; nLight < gs_nNumLights; nLight++)
        {
            float3 nLightVector = (gs_aLights[nLight].m_nPosition.xyz - nPixelPosition);
            float nDistance = length(nLightVector);
            float3 nLightNormal = normalize(nLightVector);
	
            float nAttenuation = (1.0f - saturate(nDistance / gs_aLights[nLight].m_nRange));

            float2 nLighting = GetBRDF(nPixelNormal, nLightNormal, nViewNormal, nPixelInfo);
            nLighting.x *= nAttenuation;

            kOutput.diffuse.xyz += saturate(gs_aLights[nLight].m_nColor * nLighting.x);
            kOutput.specular.xyz += saturate(gs_aLights[nLight].m_nColor * nLighting.y);
        }

        kOutput.diffuse.xyz = saturate(kOutput.diffuse.xyz);
        kOutput.specular.xyz = saturate(kOutput.specular.xyz);
        return kOutput;
    }
]]>
