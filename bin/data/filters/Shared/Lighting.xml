<![CDATA[
    Texture2D     gs_pAlbedoBuffer          : register(t1);
    Texture2D     gs_pWorldBuffer           : register(t2);
    Texture2D     gs_pInfoBuffer            : register(t3);
    Buffer<uint>  gs_pTileIndices           : register(t4);
    
    static const float gs_nPI = 3.14159265358979323846;
    static const float gs_nReciprocalPI = rcp(gs_nPI);
    static const uint2 gs_nNumTiles = asuint(ceil(gs_nCameraSize / gs_nLightTileSize));
    
    // Diffuse & Specular Term
    // http://www.gamedev.net/topic/639226-your-preferred-or-desired-brdf/
    bool GetBRDF(out float3 nFinalDiffuse, out float3 nFinalSpecular, in float4 nAlbedo, in float3 nPixelNormal, in float3 nLightNormal, in float3 nViewNormal, in float4 nInfo)
    {
        float nNormalLightAngle = saturate(dot(nPixelNormal, nLightNormal));

        [branch]
        if(nNormalLightAngle <= 0.0f)
        {
            return false;
        }
        
        float nRoughness = (nInfo.x * nInfo.x * 4);
        float nRoughnessSquared = (nRoughness * nRoughness);
        float nSpecular = nInfo.y;
        float nMetalness = nInfo.z;

        float3 Ks = lerp(nSpecular, nAlbedo.xyz, nMetalness);
        float3 Kd = lerp(nAlbedo.xyz, 0, nMetalness);
        float3 Fd = 1.0 - Ks;

        float nNormalViewAngle = dot(nPixelNormal, nViewNormal);
        float nNormalViewAngleSquared = (nNormalViewAngle * nNormalViewAngle);
        float nInvNormalViewAngleSquared = (1.0 - nNormalViewAngleSquared);

        float3 nHalfVector = normalize(nLightNormal + nViewNormal);
        float nNormalHalfAngle = saturate(dot(nPixelNormal, nHalfVector));
        float nLightHalfAngle = saturate(dot(nLightNormal, nHalfVector));

        float nNormalLightAngleSquared = (nNormalLightAngle * nNormalLightAngle);
        float nNormalHalfAngleSquared = (nNormalHalfAngle * nNormalHalfAngle);
        float nInvNormalLightAngleSquared = (1.0 - nNormalLightAngleSquared);

        nFinalDiffuse = (Kd * Fd * gs_nReciprocalPI * saturate((1 - nRoughness) * 0.5 + 0.5 + nRoughnessSquared * (8 - nRoughness) * 0.023));

        float nCenteredNormalViewAngle = (nNormalViewAngle * 0.5 + 0.5);
        float nCenteredNormalLightAngle = (nNormalLightAngle * 0.5 + 0.5);
        nNormalViewAngleSquared = (nCenteredNormalViewAngle * nCenteredNormalViewAngle);
        nNormalLightAngleSquared = (nCenteredNormalLightAngle * nCenteredNormalLightAngle);
        nInvNormalViewAngleSquared = (1.0 - nNormalViewAngleSquared);
        nInvNormalLightAngleSquared = (1.0 - nNormalLightAngleSquared);

        float nDiffuseDelta = lerp((1 / (0.1 + nRoughness)), (-nRoughnessSquared * 2), saturate(nRoughness));
        float nDiffuseViewAngle = (1 - (pow(1 - nCenteredNormalViewAngle, 4) * nDiffuseDelta));
        float nDiffuseLightAngle = (1 - (pow(1 - nCenteredNormalLightAngle, 4) * nDiffuseDelta));
        nFinalDiffuse *= (nDiffuseLightAngle * nDiffuseViewAngle * nNormalLightAngle);

        float3 Fs = (Ks + Fd * pow((1 - nLightHalfAngle), 5));
        float3 D = (pow(nRoughness / (nNormalHalfAngleSquared * (nRoughnessSquared + (1 - nNormalHalfAngleSquared) / nNormalHalfAngleSquared)), 2) / gs_nPI);
        nFinalSpecular = (Fs * D * nNormalLightAngle);
        return true;
    }
    
    void GetLightingContribution(in INPUT kInput, out float3 nTotalDiffuse, out float3 nTotalSpecular)
    {
        float4 nAlbedo = gs_pAlbedoBuffer.Sample(gs_pPointSampler, kInput.texcoord);

        float4 nPixelInfo = gs_pInfoBuffer.Sample(gs_pPointSampler, kInput.texcoord);

	    float4 nWorld = gs_pWorldBuffer.Sample(gs_pPointSampler, kInput.texcoord);
        float nPixelDepth = nWorld.w;
        float3 nPixelPosition = (nPixelDepth * kInput.view);
	    float3 nPixelNormal = nWorld.xyz;

        float3 nViewNormal = -kInput.view;

        float3 nTotalContribution = 0.0f;

        uint2 nTilePosition = asuint(kInput.position.xy / gs_nLightTileSize);
        uint nTileIndex = (nTilePosition.y * gs_nNumTiles.x + nTilePosition.x);

        nTotalDiffuse = 0;
        nTotalSpecular = 0;

        [loop]
        for(uint nLight = 0; nLight < 1; nLight++)
        {
            uint nLightIndex = gs_pTileIndices[nTileIndex + nLight];
            nTotalDiffuse.r = asfloat(nLightIndex) / 256.0f;
        }
/*
        [loop]
        for(uint nLight = 0; nLight < gs_nMaxLights && gs_aLights[nLight].m_nRange > 0.0f; nLight++)
        {
            float3 nLightVector = (gs_aLights[nLight].m_nPosition.xyz - nPixelPosition);
            float nDistance = length(nLightVector);
            float3 nLightNormal = normalize(nLightVector);
	
            float nAttenuation = (1.0f - saturate(nDistance * gs_aLights[nLight].m_nInvRange));
            
            [branch]
            if(nAttenuation > 0.0f)
            {
                float3 nCurrentDiffuse = 0.0f;
                float3 nCurrentSpecular = 0.0f;

                [branch]
                if(GetBRDF(nCurrentDiffuse, nCurrentSpecular, nAlbedo, nPixelNormal, nLightNormal, nViewNormal, nPixelInfo))
                {
                    nTotalDiffuse += saturate(gs_aLights[nLight].m_nColor * nCurrentDiffuse * nAttenuation);
                    nTotalSpecular += saturate(gs_aLights[nLight].m_nColor * nCurrentSpecular * nAttenuation);
                }
            }
        }
*/
        nTotalDiffuse = saturate(nTotalDiffuse);
        nTotalSpecular = saturate(nTotalSpecular);
    }
]]>
