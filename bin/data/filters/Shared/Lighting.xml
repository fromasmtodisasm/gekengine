<![CDATA[
    Texture2D     gs_pAlbedoBuffer          : register(t0);
    Texture2D     gs_pWorldBuffer           : register(t1);
    Texture2D     gs_pInfoBuffer            : register(t2);

    struct LIGHT
    {
        float4 m_nPosition;
        float3 m_nColor;
        float  m_nRange;
    };
    
    StructuredBuffer<LIGHT> gs_aLights      : register(t3);
    
    struct OUTPUT
    {
        float4 screen                       : SV_TARGET0;
        float4 buffer                       : SV_TARGET1;
    };

    // Diffuse & Specular Term
    // http://www.gamedev.net/topic/639226-your-preferred-or-desired-brdf/
    float3 GetBRDF(float3 nAlbedo, float3 nPixelNormal, float3 nLightNormal, float3 nViewNormal, float4 nInfo)
    {
        const float gs_nPI = 3.14159265358979323846;
        const float gs_nReciprocalPI = (1.0f / gs_nPI);

        float nRoughness = (nInfo.x * nInfo.x * 4);
        float nRoughnessSquared = (nRoughness * nRoughness);
        float nSpecular = nInfo.y;
        float nMetalness = nInfo.z;

        float3 Ks = lerp(nSpecular, nAlbedo, nMetalness);
        float3 Kd = lerp(nAlbedo, 0, nMetalness);
        float3 Fd = 1.0 - Ks;

        float nNormalViewAngle = dot(nPixelNormal, nViewNormal);
        float nNormalViewAngleSquared = (nNormalViewAngle * nNormalViewAngle);
        float nInvNormalViewAngleSquared = (1.0 - nNormalViewAngleSquared);

        float3 nHalfVector = normalize(nLightNormal + nViewNormal);
        float nNormalLightAngle = saturate(dot(nPixelNormal, nLightNormal));
        float nNormalHalfAngle = saturate(dot(nPixelNormal, nHalfVector));
        float nLightHalfAngle = saturate(dot(nLightNormal, nHalfVector));

        float nNormalLightAngleSquared = (nNormalLightAngle * nNormalLightAngle);
        float nNormalHalfAngleSquared = (nNormalHalfAngle * nNormalHalfAngle);
        float nInvNormalLightAngleSquared = (1.0 - nNormalLightAngleSquared);

        float3 nFinalDiffuse = (Kd * Fd * gs_nReciprocalPI * saturate((1 - nRoughness) * 0.5 + 0.5 + nRoughnessSquared * (8 - nRoughness) * 0.023));

        float3 D = (pow(nRoughness/(nNormalHalfAngleSquared * (nRoughnessSquared + (1 - nNormalHalfAngleSquared) / nNormalHalfAngleSquared)), 2) / gs_nPI);

        nNormalViewAngle = (nNormalViewAngle * 0.5 + 0.5);
        nNormalLightAngle = (nNormalLightAngle * 0.5 + 0.5);
        nNormalLightAngleSquared = (nNormalLightAngle * nNormalLightAngle);
        nNormalViewAngleSquared = (nNormalViewAngle * nNormalViewAngle);
        nInvNormalLightAngleSquared = (1.0 - nNormalLightAngleSquared);
        nInvNormalViewAngleSquared = (1.0 - nNormalViewAngleSquared);

        float nDiffuseDelta = lerp((1 / (0.1 + nRoughness)), (-nRoughnessSquared * 2), saturate(nRoughness));
        float nDiffuseLightAngle = (1 - (pow(1 - nNormalLightAngle, 4) * nDiffuseDelta));
        float nDiffuseViewAngle = (1 - (pow(1 - nNormalViewAngle, 4) * nDiffuseDelta));
        nFinalDiffuse *= (nDiffuseLightAngle * nDiffuseViewAngle);

        float3 Fs = (Ks + Fd * pow((1 - nLightHalfAngle), 5));

        float3 nFinalSpecular = (Fs * D);

        return ((nFinalDiffuse + nFinalSpecular) * saturate(dot(nPixelNormal, nLightNormal)));
    }
    
    OUTPUT MainPixelProgram(INPUT kInput)
    {
        float4 nAlbedo = gs_pAlbedoBuffer.Sample(gs_pPointSampler, kInput.texcoord);

        float4 nPixelInfo = gs_pInfoBuffer.Sample(gs_pPointSampler, kInput.texcoord);

	    float4 nWorld = gs_pWorldBuffer.Sample(gs_pPointSampler, kInput.texcoord);
        float nPixelDepth = nWorld.w;
        float3 nPixelPosition = (nPixelDepth * kInput.view);
	    float3 nPixelNormal = nWorld.xyz;

        float3 nViewNormal = -kInput.view;

        OUTPUT kOutput = (OUTPUT)0;
        for(uint nLight = 0; gs_aLights[nLight].m_nRange > 0.0f; nLight++)
        {
            float3 nLightVector = (gs_aLights[nLight].m_nPosition.xyz - nPixelPosition);
            float nDistance = length(nLightVector);
            float3 nLightNormal = normalize(nLightVector);
	
            float nAttenuation = (1.0f - saturate(nDistance / gs_aLights[nLight].m_nRange));

            float3 nLighting = GetBRDF(nAlbedo, nPixelNormal, nLightNormal, nViewNormal, nPixelInfo);
            nLighting *= nAttenuation;

            kOutput.buffer.xyz += saturate(gs_aLights[nLight].m_nColor * nLighting);
        }

        kOutput.screen.xyz = kOutput.buffer.xyz = saturate(kOutput.buffer.xyz);
        return kOutput;
    }
]]>
