<?xml version="1.0"?>
<filter>
    <defines>
        <!--define name="gs_nPi" value=" 3.14159265" /-->
    </defines>

    <pixel>
        <resources>
            <resource stage="1" source="Opaque/Deferred.Albedo" />
            <resource stage="2" source="Opaque/Deferred.World" />
        </resources>

        <![CDATA[
            Texture2D     gs_pAlbedoBuffer          : register(t1);
            Texture2D     gs_pWorldBuffer           : register(t2);

            static const float gNumSamples = 11.0;
            static const float gRadius = 1.0;
            static const float gRadius2 = gRadius * gRadius;
            static const float gProjScale = 500.0;
            static const float gNumSpiralTurns = 7;
            static const float gBias = 0.01;
            static const float gIntensity = 1.0;
            static const float2 gScreenSize = float2(1280, 800);

            float3 reconstructNormal(float3 positionViewSpace)
            {
                return normalize(cross(ddx(positionViewSpace), ddy(positionViewSpace)));
            }

            float3 getOffsetPosition(INPUT kInput, const int2 ssC, const float2 unitOffset, const float ssR)
            {
                uint2 ssP = uint2(ssR*unitOffset) + ssC;

                const float2 texCoord = float2(ssP.x / gScreenSize.x, ssP.y / gScreenSize.y);

	            float4 nSampleInfo = gs_pWorldBuffer.Sample(gs_pPointSampler, texCoord);
                float nSampleDepth = nSampleInfo.w;
	            return (nSampleDepth * kInput.view);
            }

            float2 tapLocation(int sampleNumber, float spinAngle, out float ssR)
            {
                // Radius relative to ssR
                float alpha = float(sampleNumber + 0.5) * (1.0 / gNumSamples);
                float angle = alpha * (gNumSpiralTurns * 6.28) + spinAngle;

                ssR = alpha;
                return float2(cos(angle), sin(angle));
            }

            float sampleAO(INPUT kInput, uint2 screenSpacePos, float3 originPos, float3 normal, float ssDiskRadius, int tapIndex, float randomPatternRotationAngle)
            {
                float ssR;
                float2 unitOffset = tapLocation(tapIndex, randomPatternRotationAngle, ssR);
                ssR *= ssDiskRadius;

                // The occluding point in camera space
                float3 Q = getOffsetPosition(kInput, screenSpacePos, unitOffset, ssR);

                float3 v = Q - originPos;

                float vv = dot(v, v);
                float vn = dot(v, normal);

                const float epsilon = 0.01;
                float f = max(gRadius2 - vv, 0.0); 
    
                return f * f * f * max((vn - gBias) / (epsilon + vv), 0.0);
            }

            float4 MainPixelProgram(INPUT kInput) : SV_TARGET0
            {
	            float4 nCenterInfo = gs_pWorldBuffer.Sample(gs_pPointSampler, kInput.texcoord);
                float nCenterDepth = nCenterInfo.w;
	            float3 nCenterPosition = (nCenterDepth * kInput.view);
	            float3 nCenterNormal = nCenterInfo.xyz;

                float nWidth, nHeight;
                gs_pWorldBuffer.GetDimensions(nWidth, nHeight);

                // Hash function used in the HPG12 AlchemyAO paper
                float randomPatternRotationAngle = (3 * int(kInput.position.x) ^ int(kInput.position.y) + int(kInput.position.x) * int(kInput.position.y)) * 10;
                float ssDiskRadius = -gProjScale * gRadius / nCenterPosition.z;

                float ao = 0.0;
                
                [unroll]
                for (int i = 0; i < gNumSamples; i++)
                {
                    ao += sampleAO(kInput, kInput.position.xy, nCenterPosition, nCenterNormal, ssDiskRadius, i, randomPatternRotationAngle);
                }

                float temp = gRadius2 * gRadius;
                ao /= temp * temp;

                float A = max(0.0, 1.0 - ao * gIntensity * (8.0 / gNumSamples));

                return A;
			}
        ]]>
    </pixel>
</filter>
