<?xml version="1.0"?>
<filter mode="forward">
    <render cullmode="back" />
    
    <targets>
        <target name="Albedo" format="RGBA_UINT8"/>
        <target name="World" format="RGBA_HALF"/>
        <target name="Info" format="RGBA_UINT8"/>
        <depth format="D24S8" comparison="lessequal" writemask="all" clear="1" />
    </targets>
    
    <pixel>
        <![CDATA[
            Texture2D     gs_pAlbedoMap             : register(t0);
            Texture2D     gs_pNormalMap             : register(t1);
            Texture2D     gs_pInfoMap               : register(t2);

            struct OUTPUT
            {
                float4 albedo                       : SV_TARGET0;
                float4 world                        : SV_TARGET1;
                float4 info                         : SV_TARGET2;
            };

            float3x3 GetCoTangentFrame( float3 nNormal, float3 nPosition, float2 nTexCoord )
            {
                // get edge vectors of the pixel triangle
                float3 nPositionDDX = ddx( nPosition );
                float3 nPositionDDY = ddy( nPosition );
                float2 nTexCoordDDX = ddx( nTexCoord );
                float2 nTexCoordDDY = ddy( nTexCoord );
 
                // solve the linear system
                float3 nPerpendicularDDX = cross( nNormal, nPositionDDX );
                float3 nPerpendicularDDY = cross( nPositionDDY, nNormal );
                float3 nTangent = nPerpendicularDDY * nTexCoordDDX.x + nPerpendicularDDX * nTexCoordDDY.x;
                float3 nBiTangent = nPerpendicularDDY * nTexCoordDDX.y + nPerpendicularDDX * nTexCoordDDY.y;
 
                // construct a scale-invariant frame 
                float nReciprocal = rsqrt( max( dot(nTangent,nTangent), dot(nBiTangent,nBiTangent) ) );
                return float3x3( nTangent * nReciprocal, nBiTangent * nReciprocal, nNormal );
            }

            OUTPUT MainPixelProgram(in INPUT kInput)
            {
                float4 nAlbedo = (gs_pAlbedoMap.Sample(gs_pLinearSampler, kInput.texcoord) * gs_nMaterialColor * kInput.color);

                [branch]
                if(nAlbedo.a < 0.5f)
                {
                    discard;
                }

                float3x3 nCoTangentFrame = GetCoTangentFrame(normalize(kInput.viewnormal), normalize(-kInput.viewposition.xyz), kInput.texcoord);
                float3 nNormal = ((gs_pNormalMap.Sample(gs_pLinearSampler, kInput.texcoord).xyz * 2.0) - 1.0f);
                nNormal = normalize(mul(nNormal, nCoTangentFrame) * (kInput.frontface ? 1 : -1));

                OUTPUT kOutput;
                kOutput.albedo.xyz = nAlbedo.xyz;
                kOutput.albedo.a   = gs_bMaterialFullBright;
                kOutput.world.xyz  = nNormal;
                kOutput.world.w    = kInput.viewposition.z;
                kOutput.info       = gs_pInfoMap.Sample(gs_pLinearSampler, kInput.texcoord);
                return kOutput;
            }
        ]]>
    </pixel>
</filter>
