<?xml version="1.0"?>
<filter>
    <defines>
        <define name="gs_nDomainSigma" value="2" />
        <define name="gs_nRangeSigma" value=".02" />
        <define name="gs_nBiLateralSize" value="5" />
    </defines>

    <blend>
        <color source="destination_color" destination="zero" operation="add" />
        <alpha source="destination_alpha" destination="zero" operation="add" />
    </blend>

    <pixel>
        <resources>
            <resource stage="1" source="Opaque/Deferred.Albedo" />
            <resource stage="2" source="Opaque/Deferred.Depth" />
            <resource stage="3" source="Opaque/SSAO.Ambient" />
        </resources>
        
        <![CDATA[
            Texture2D           gs_pAlbedoBuffer        : register(t1);
            Texture2D<float>    gs_pDepthBuffer         : register(t2);
            Texture2D<float>    gs_pAmbientBuffer       : register(t3);

            static const float gs_nDomainSigmaSquared = (gs_nDomainSigma * gs_nDomainSigma);
            static const float gs_nRangeSigmaSquared = (gs_nRangeSigma * gs_nRangeSigma);

            float4 MainPixelProgram(INPUT kInput) : SV_TARGET
            {
                float4 nAlbedo = gs_pAlbedoBuffer.Sample(gs_pPointSampler, kInput.texcoord);
                
                [branch]
                if(nAlbedo.w == 1.0)
                {
                    return 1;
                }

                float2 nSize;
                gs_pAmbientBuffer.GetDimensions(nSize.x, nSize.y);
                nSize = rcp(nSize);                

                float3 nTotalAmbient = 0.0f;
                float nTotalIntensity = 0.0f;
                float nCurrentDepth = gs_pDepthBuffer.Sample(gs_pPointSampler, kInput.texcoord);
                
                [unroll]
                for(float nXPos = -gs_nBiLateralSize; nXPos <= gs_nBiLateralSize; nXPos += 1.0f)
                {
                    float nXCoord = (kInput.texcoord.x + (nXPos * nSize.x));

                    [unroll]
                    for(float nYPos = -gs_nBiLateralSize; nYPos <= gs_nBiLateralSize; nYPos += 1.0f)
                    {
                        float nYCoord = (kInput.texcoord.y + (nYPos * nSize.y));
                        float nSampleDepth = gs_pDepthBuffer.Sample(gs_pPointSampler, float2(nXCoord, nYCoord));
                        float nSampleAmbient = gs_pAmbientBuffer.Sample(gs_pPointSampler, float2(nXCoord, nYCoord));

                        float nDistance = (float(nXPos * nXPos) + float(nYPos * nYPos));
                        float nIntensity = exp((-1.0 * nDistance / (2.0 * gs_nDomainSigmaSquared))) / ( 2.0f * gs_nPI *  gs_nDomainSigmaSquared) *
                                           exp((-1.0 * (nCurrentDepth - nSampleDepth) * (nCurrentDepth - nSampleDepth) / (gs_nRangeSigmaSquared)));
                        nTotalIntensity += nIntensity;
                        nTotalAmbient += (nIntensity * nSampleAmbient);
                    }
                }

                return float4((nTotalAmbient / nTotalIntensity), 1.0f);
            }
        ]]>
    </pixel>
</filter>
