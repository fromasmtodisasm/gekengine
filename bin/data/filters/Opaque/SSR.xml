<?xml version="1.0"?>
<filter flipscreens="true">
    <pixel>
        <resources>
            <resource stage="1" source="Opaque/Deferred.Albedo" />
            <resource stage="2" source="Opaque/Deferred.Normal" />
            <resource stage="3" source="Opaque/Deferred.Depth" />
            <resource stage="4" source="Opaque/Deferred.Info" />
            <resource stage="5" source="screen" />
        </resources>

        <![CDATA[
            Texture2D           gs_pAlbedoBuffer        : register(t1);
            Texture2D<half2>    gs_pNormalBuffer        : register(t2);
            Texture2D<float>    gs_pDepthBuffer         : register(t3);
            Texture2D           gs_pInfoBuffer          : register(t4);
            Texture2D           gs_pScreenBuffer        : register(t5);

            float4 MainPixelProgram(INPUT kInput) : SV_TARGET
            {
                float4 nScreen = gs_pScreenBuffer.Sample(gs_pPointSampler, kInput.texcoord);
                if(gs_pAlbedoBuffer.Sample(gs_pPointSampler, kInput.texcoord).w < 1.0f)
                {
                    float4 nCenterInfo = gs_pInfoBuffer.Sample(gs_pPointSampler, kInput.texcoord);
                    float nReflectivity = nCenterInfo.w;
	                if(nReflectivity > 0.0f)
                    {
                        float nCenterDepth = gs_pDepthBuffer.Sample(gs_pPointSampler, kInput.texcoord);
                        float3 nCenterPosition = GetViewPosition(kInput.texcoord, nCenterDepth);
	                    float3 nCenterNormal = DecodeNormal(gs_pNormalBuffer.Sample(gs_pPointSampler, kInput.texcoord));

                        float3 nViewNormal = normalize(nCenterPosition);
		                float3 nReflection = reflect(nViewNormal, nCenterNormal);
		                float nViewDotNormal = dot(nViewNormal, nCenterNormal);

		                // FRESNEL
		                nReflectivity = (nReflectivity * pow((1.0 - abs(nViewDotNormal)), 1.0));
		
		                float nStepSize = .5;
		                float nNumSteps = 30.0;
		                float nNumStepsBack = 15.0;
		                float nStep = 0;
		
		                float3 nRayPosition = nCenterPosition;
		                float nRealStep = nNumSteps;
		
		                // FOLLOWING THE REFLECTED RAY 
		                while(nStep < nNumSteps)
                        {
			                nRayPosition += (nReflection.xyz * nStepSize);
			                float4 nTexCoord = mul(gs_nProjectionMatrix, float4(nRayPosition, 1));
                            nTexCoord.xy = ((((nTexCoord.xy * float2(1.0f, -1.0f)) / nTexCoord.w) * 0.5f) + 0.5f);
                            float nSampleDepth = gs_pDepthBuffer.Sample(gs_pPointSampler, nTexCoord.xy);
	                        float2 nSamplePosition = GetViewPosition(nTexCoord, nSampleDepth);
                            if(nSamplePosition.z <= nRayPosition.z)
                            {
				                nRealStep = nStep;
				                nStep = nNumSteps;				
			                }
			                else
                            {
				                nStep++;
                            }
		                };

		                // IF WE HAVE HIT SOMETHING - FOLLOWING THE RAY BACKWARD USING SMALL STEP FOR BETTER PRECISION
		                if(nRealStep < nNumSteps)
                        {
			                nStep = 0;		
			                while(nStep < nNumStepsBack)
                            {	
				                nRayPosition -= (nReflection.xyz * nStepSize / nNumStepsBack);
				                float4 nTexCoord = mul(gs_nProjectionMatrix, float4(nRayPosition, 1));
		                        nTexCoord.xy = ((((nTexCoord.xy * float2(1.0f, -1.0f)) / nTexCoord.w) * 0.5f) + 0.5f);
                                float nSampleDepth = gs_pDepthBuffer.Sample(gs_pPointSampler, nTexCoord.xy);
	                            float2 nSamplePosition = GetViewPosition(nTexCoord, nSampleDepth);
				                if(nSamplePosition.z > nRayPosition.z)
                                {
					                nStep = nNumStepsBack;				
                                }
				                else
                                {
					                nStep++;
                                }
			                };
		                }
		
		                // FADING REFLECTION DEPENDING ON RAY LENGTH
		                nReflectivity = (nReflectivity * (1.0 - (nRealStep / nNumSteps)));
		
		                // FADING REFLECTION ON SCREEN BORDER // AVOIDS ABRUPT REFLECTION ENDINGS
		                float2 tAtt = nTexCoord.xy;
		                if(tAtt.x > 0.5) tAtt.x = (1.0 - tAtt.x);
		                if(tAtt.y > 0.5) tAtt.y = (1.0 - tAtt.y);
		
		                nReflectivity = (nReflectivity * clamp((tAtt.x * 10.0), 0.0, 1.0));
		                nReflectivity = (nReflectivity * clamp((tAtt.y * 10.0), 0.0, 1.0));
		
		                // AVOIDING REFLECTION OF OBJECTS IN FOREGROUND 
		                nReflectivity = (nReflectivity * 1.0 / (1.0 + (abs(nSamplePosition.z - nRayPosition.z) * 20)));
		
		                // COMBINING REFLECTION TO THE ORIGINAL PIXEL COLOR
		                if(nReflectivity > 0.0)
                        {
                            nScreen = lerp(nScreen, gs_pScreenBuffer.Sample(gs_pPointSampler, nTexCoord.xy), nReflectivity);
		                }
	                }
                }
                
                return nScreen;
            }
        ]]>
    </pixel>
</filter>
