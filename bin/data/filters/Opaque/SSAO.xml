<?xml version="1.0"?>
<filter>
    <targets>
        <target name="Ambient" format="RGBA_UINT8"/>
    </targets>

    <pixel>
        <resources>
            <resource stage="1" source="Opaque/Deferred.Albedo" />
            <resource stage="2" source="Opaque/Deferred.Normal" />
            <resource stage="3" source="Opaque/Deferred.Depth" />
        </resources>

        <![CDATA[
            Texture2D     gs_pAlbedoBuffer          : register(t1);
            Texture2D     gs_pNormalBuffer          : register(t2);
            Texture2D     gs_pDepthBuffer           : register(t3);

            #define PI 3.14159265

            static const int samplesCount = 16;
            static const int spiralTurns = 10;

            static const float radius = 0.1;
            static const float beta = 0.4;
            static const float epsilon = 0.01;

            float2 tapLocation(int sampleNumber, float spinAngle)
            {
	            float alpha = float(sampleNumber + 0.5) * (1.0 / samplesCount);
	            float angle = alpha * (spiralTurns * 2 * PI) + spinAngle;
	            return alpha * float2(cos(angle), sin(angle));
            }
            
            half3 DecodeNormal (half4 enc)
            {
                half4 nn = enc*half4(2,2,0,0) + half4(-1,-1,1,-1);
                half l = dot(nn.xyz,-nn.xyw);
                nn.z = l;
                nn.xy *= sqrt(l);
                return nn.xyz * 2 + half3(0,0,-1);
            }

            float4 MainPixelProgram(INPUT kInput) : SV_TARGET
            {
                float nCenterDepth = gs_pDepthBuffer.Sample(gs_pPointSampler, kInput.texcoord).x;
                float nCenterLinearDepth = ((nCenterDepth - gs_nCameraMinDistance) / (gs_nCameraMaxDistance - gs_nCameraMinDistance));
                float3 nCenterPosition = (nCenterDepth * kInput.view);
	            float3 nCenterNormal = DecodeNormal(gs_pNormalBuffer.Sample(gs_pPointSampler, kInput.texcoord));

                float2 nSize;
                gs_pDepthBuffer.GetDimensions(nSize.x, nSize.y);
	            float2 pixelPosition = kInput.texcoord * nSize;
	            float random = (3*int(pixelPosition.x)^int(pixelPosition.y)+int(pixelPosition.x)*int(pixelPosition.y))*10.0;
	            float diskRadius = radius / (2 * nCenterDepth * gs_nCameraFieldOfView.x);
                
                float ao = 0;

	            [unroll]
	            for(int sampleIndex=0; sampleIndex < samplesCount; sampleIndex++)
	            {
		            float2 offset = tapLocation(sampleIndex, random);
		            float2 samplePosition = kInput.texcoord + diskRadius * offset;
	                float3 samplePoint = gs_pDepthBuffer.Sample(gs_pPointSampler, samplePosition).x * kInput.view;
		            float3 v = samplePoint - nCenterPosition;
		            float vv = dot(v, v);
		            float vn = dot(v, nCenterNormal);
		            if(nCenterLinearDepth < 1) //do not AO for far plane
                    {
			            ao += max(0, vn + nCenterLinearDepth * 0.001) / (vv + epsilon);
                    }
	            }

	            ao *= 2.0 * PI * radius * beta / samplesCount;
	            ao = min(1, max(0, 1 - ao));
	            return ao;
            }
        ]]>
    </pixel>
</filter>
