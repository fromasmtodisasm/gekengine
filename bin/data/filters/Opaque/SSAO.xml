<?xml version="1.0"?>
<filter>
    <targets>
        <target name="Ambient" format="RGBA_UINT8"/>
    </targets>

    <pixel>
        <resources>
            <resource stage="1" source="Opaque/Deferred.Albedo" />
            <resource stage="2" source="Opaque/Deferred.Normal" />
            <resource stage="3" source="Opaque/Deferred.Depth" />
        </resources>

        <![CDATA[
            Texture2D     gs_pAlbedoBuffer          : register(t1);
            Texture2D     gs_pNormalBuffer          : register(t2);
            Texture2D     gs_pDepthBuffer           : register(t3);

            #define PI 3.14159265

            static const int gs_nNumSamples = 16;
            static const int gs_nNumSpirals = 10;

            static const float gs_nRadius = 0.1f;
            static const float gs_nRadiusSquared = (gs_nRadius * gs_nRadius);
            static const float gs_nIntensity = 1.0f;
            static const float gs_nBias = 0.01f;
            static const float gs_nBeta = 0.4f;
            static const float gs_nEpsilon = 0.01f;

            float2 TapLocation(int sampleNumber, float spinAngle, out float ssR)
            {
	            // Radius relative to ssR
	            float alpha = float(sampleNumber + 0.5) * (1.0 / gs_nNumSamples);
	            float angle = alpha * (gs_nNumSpirals * 6.28) + spinAngle;

	            ssR = alpha;
	            return float2(cos(angle), sin(angle));
            }
            
            half3 DecodeNormal(half4 nEncoded)
            {
                half4 nNormal = ((nEncoded * half4(2, 2, 0, 0)) + half4(-1, -1, 1, -1));
                half nLength = dot(nNormal.xyz, -nNormal.xyw);
                nNormal.z = nLength;
                nNormal.xy *= sqrt(nLength);
                return ((nNormal.xyz * 2.0f) + half3(0, 0, -1));
            }

            float4 MainPixelProgram(INPUT kInput) : SV_TARGET
            {
                float nCenterDepth = gs_pDepthBuffer.Sample(gs_pPointSampler, kInput.texcoord).x;
                float nCenterLinearDepth = ((nCenterDepth - gs_nCameraMinDistance) / (gs_nCameraMaxDistance - gs_nCameraMinDistance));
                float3 nCenterPosition = (nCenterDepth * kInput.view);
	            float3 nCenterNormal = DecodeNormal(gs_pNormalBuffer.Sample(gs_pPointSampler, kInput.texcoord));

                float2 nSize;
                gs_pDepthBuffer.GetDimensions(nSize.x, nSize.y);
	            int2 nPixelCoord = kInput.texcoord * nSize;
	            float nRandomAngle = (3 * nPixelCoord.x ^ nPixelCoord.y + nPixelCoord.x * nPixelCoord.y) * 10;

	            float nDiskRadius = -500 * gs_nRadius / nCenterDepth;

	            float nOcclusion = 0;

	            [unroll]
	            for(int nSample = 0; nSample < gs_nNumSamples; nSample++)
	            {
	                float nSampleRadius;
	                float2 nSampleOffset = TapLocation(nSample, nRandomAngle, nSampleRadius);
	                nSampleRadius *= nDiskRadius;
                    float2 nSampleCoord = kInput.texcoord + (nSampleOffset * nSampleRadius);
                    float nSampleDepth = gs_pDepthBuffer.Sample(gs_pPointSampler, nSampleCoord).x;
                    float3 nSamplePosition = (nSampleDepth * kInput.view);

	                float3 v = nSamplePosition - nCenterPosition;
	                float vv = dot(v, v);
	                float vn = dot(v, nCenterNormal);
                    float f = max(gs_nRadiusSquared - vv, 0.0);
                    nOcclusion += f * f * f * max((vn - gs_nBias) / (gs_nEpsilon + vv), 0.0);
	            }

                float nTemp = gs_nRadiusSquared * gs_nRadius;
                nOcclusion /= nTemp * nTemp;
	            nOcclusion = max(0.0, 1.0 - nOcclusion * gs_nIntensity * (5.0 / gs_nNumSamples));
	            return float4(nOcclusion, nOcclusion, nOcclusion, 1);
            }
        ]]>
    </pixel>
</filter>
