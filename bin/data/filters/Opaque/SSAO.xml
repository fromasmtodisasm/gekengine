<?xml version="1.0"?>
<filter>
    <targets>
        <target name="Ambient" format="RGBA_UINT8"/>
    </targets>

    <pixel>
        <resources>
            <resource stage="1" source="Opaque/Deferred.Albedo" />
            <resource stage="2" source="Opaque/Deferred.World" />
            <resource stage="3" source="Opaque/Deferred.Info" />
        </resources>

        <![CDATA[
            Texture2D     gs_pAlbedoBuffer          : register(t1);
            Texture2D     gs_pWorldBuffer           : register(t2);
            Texture2D     gs_pInfoBuffer            : register(t3);

            #define PI 3.14159265

            static const float halfFOV = 1.57079633 / 2;

            static const int samplesCount = 16;
            static const int spiralTurns = 10;

            static const float radius = 0.1;
            static const float beta = 0.4;
            static const float epsilon = 0.01;

            float2 tapLocation(int sampleNumber, float spinAngle)
            {
	            float alpha = float(sampleNumber + 0.5) * (1.0 / samplesCount);
	            float angle = alpha * (spiralTurns * 2 * PI) + spinAngle;
	            return alpha * float2(cos(angle), sin(angle));
            }
            
            float4 MainPixelProgram(INPUT kInput) : SV_TARGET
            {
	            float4 nCenterData = gs_pWorldBuffer.Sample(gs_pPointSampler, kInput.texcoord);
                float nCenterDepth = nCenterData.w;
                float nCenterLinearDepth = (nCenterData.w / gs_nCameraViewDistance);
                float3 nCenterPosition = (nCenterDepth * kInput.view);
	            float3 nCenterNormal = nCenterData.xyz;

                float2 nSize;
                gs_pWorldBuffer.GetDimensions(nSize.x, nSize.y);
	            float2 pixelPosition = kInput.texcoord * nSize;
	            float random = (3*int(pixelPosition.x)^int(pixelPosition.y)+int(pixelPosition.x)*int(pixelPosition.y))*10.0;
	            float diskRadius = radius / (2 * nCenterDepth * tan(halfFOV));
                
                float ao = 0;

	            [unroll]
	            for(int sampleIndex=0; sampleIndex < samplesCount; sampleIndex++)
	            {
		            float2 offset = tapLocation(sampleIndex, random);
		            float2 samplePosition = kInput.texcoord + diskRadius * offset;
	                float3 samplePoint = gs_pWorldBuffer.Sample(gs_pPointSampler, samplePosition).w * kInput.view;
		            float3 v = samplePoint - nCenterPosition;
		            float vv = dot(v, v);
		            float vn = dot(v, nCenterNormal);
		            if(nCenterLinearDepth < 1) //do not AO for far plane
                    {
			            ao += max(0, vn + nCenterLinearDepth * 0.001) / (vv + epsilon);
                    }
	            }

	            ao *= 2.0 * PI * radius * beta / samplesCount;
	            ao = min(1, max(0, 1 - ao));
	            return ao;
            }
        ]]>
    </pixel>
</filter>
