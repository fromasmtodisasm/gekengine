 addons/imguidock/imguidock.cpp                     | 2062 ++++++++++----------
 addons/imguidock/imguidock.h                       |   40 +-
 addons/imguifilesystem/imguifilesystem.cpp         |   47 +-
 addons/imguinodegrapheditor/imguinodegrapheditor.h |    2 +-
 addons/imguipanelmanager/imguipanelmanager.cpp     |    2 +-
 addons/imguipanelmanager/imguipanelmanager.h       |    3 +-
 .../imguivariouscontrols/imguivariouscontrols.cpp  |    2 +
 addons/imguivariouscontrols/imguivariouscontrols.h |    2 +
 imgui.cpp                                          |   71 +-
 imgui.h                                            |   10 +-
 imgui_draw.cpp                                     |    2 -
 11 files changed, 1168 insertions(+), 1075 deletions(-)

diff --git a/addons/imguidock/imguidock.cpp b/addons/imguidock/imguidock.cpp
index a25d558..5fefc5b 100644
--- a/addons/imguidock/imguidock.cpp
+++ b/addons/imguidock/imguidock.cpp
@@ -36,1283 +36,1317 @@ SOFTWARE.
 
 #include "imguidock.h"
 
+#include <unordered_map>
+
 bool gImGuiDockReuseTabWindowTextureIfAvailable = true;
 
-namespace ImGui	{
+namespace ImGui {
 
-struct DockContext
-{
-    enum EndAction_
+    static const ImGuiDockSlot SlotIndex[] =
     {
-        EndAction_None,
-        EndAction_Panel,
-        EndAction_End,
-        EndAction_EndChild
+        ImGuiDockSlot_Left,
+        ImGuiDockSlot_Right,
+        ImGuiDockSlot_Top,
+        ImGuiDockSlot_Bottom,
+        ImGuiDockSlot_Tab,
     };
 
-
-    enum Status_
+    struct DockContext
     {
-        Status_Docked,
-        Status_Float,
-        Status_Dragged
-    };
+        enum EndAction_
+        {
+            EndAction_None,
+            EndAction_Panel,
+            EndAction_End,
+            EndAction_EndChild
+        };
 
 
-    struct Dock
-    {
-        Dock()
-            : label(NULL)
-            , id(0)
-            , next_tab(NULL)
-            , prev_tab(NULL)
-            , parent(NULL)
-            , active(true)
-            , pos(0, 0)
-            , size(-1, -1)
-            , status(Status_Float)
-	    , last_frame(0)
-	    , invalid_frames(0)
-            , opened(false)
-	    , first(false)
+        enum Status_
+        {
+            Status_Docked,
+            Status_Float,
+            Status_Dragged
+        };
+
 
+        struct Dock
         {
-            location[0] = 0;
-            children[0] = children[1] = NULL;
-        }
+            Dock(ImGuiWindowFlags extra_flags)
+                : label(NULL)
+                , id(0)
+                , next_tab(NULL)
+                , prev_tab(NULL)
+                , parent(NULL)
+                , active(true)
+                , pos(0, 0)
+                , size(-1, -1)
+                , status(Status_Float)
+                , extra_flags(extra_flags)
+                , last_frame(0)
+                , invalid_frames(0)
+                , opened(false)
+                , first(false)
 
+            {
+                location[0] = 0;
+                children[0] = children[1] = NULL;
+            }
 
-        ~Dock() { MemFree(label); }
 
+            ~Dock() { MemFree(label); }
 
-        ImVec2 getMinSize() const
-        {
-            if (!children[0]) return ImVec2(16, 16 + GetTextLineHeightWithSpacing());
 
-            ImVec2 s0 = children[0]->getMinSize();
-            ImVec2 s1 = children[1]->getMinSize();
-            return isHorizontal() ? ImVec2(s0.x + s1.x, ImMax(s0.y, s1.y))
-                                  : ImVec2(ImMax(s0.x, s1.x), s0.y + s1.y);
-        }
+            ImVec2 getMinSize() const
+            {
+                if (!children[0]) return ImVec2(16, 16 + GetTextLineHeightWithSpacing());
 
+                ImVec2 s0 = children[0]->getMinSize();
+                ImVec2 s1 = children[1]->getMinSize();
+                return isHorizontal() ? ImVec2(s0.x + s1.x, ImMax(s0.y, s1.y))
+                    : ImVec2(ImMax(s0.x, s1.x), s0.y + s1.y);
+            }
 
-        bool isHorizontal() const { return children[0]->pos.x < children[1]->pos.x; }
 
+            bool isHorizontal() const { return children[0]->pos.x < children[1]->pos.x; }
 
-        void setParent(Dock* dock)
-        {
-            parent = dock;
-            for (Dock* tmp = prev_tab; tmp; tmp = tmp->prev_tab) tmp->parent = dock;
-            for (Dock* tmp = next_tab; tmp; tmp = tmp->next_tab) tmp->parent = dock;
-        }
-        
-        Dock& getRoot()
-        {
-            Dock *dock = this;
-            while (dock->parent)
-                dock = dock->parent;
-            return *dock;
-        }
 
+            void setParent(Dock* dock)
+            {
+                parent = dock;
+                for (Dock* tmp = prev_tab; tmp; tmp = tmp->prev_tab) tmp->parent = dock;
+                for (Dock* tmp = next_tab; tmp; tmp = tmp->next_tab) tmp->parent = dock;
+            }
 
-        Dock& getSibling()
-        {
-            IM_ASSERT(parent);
-            if (parent->children[0] == &getFirstTab()) return *parent->children[1];
-            return *parent->children[0];
-        }
+            Dock& getRoot()
+            {
+                Dock *dock = this;
+                while (dock->parent)
+                    dock = dock->parent;
+                return *dock;
+            }
 
 
-        Dock& getFirstTab()
-        {
-            Dock* tmp = this;
-            while (tmp->prev_tab) tmp = tmp->prev_tab;
-            return *tmp;
-        }
+            Dock& getSibling()
+            {
+                IM_ASSERT(parent);
+                if (parent->children[0] == &getFirstTab()) return *parent->children[1];
+                return *parent->children[0];
+            }
 
 
-        void setActive()
-        {
-            active = true;
-            for (Dock* tmp = prev_tab; tmp; tmp = tmp->prev_tab) tmp->active = false;
-            for (Dock* tmp = next_tab; tmp; tmp = tmp->next_tab) tmp->active = false;
-        }
+            Dock& getFirstTab()
+            {
+                Dock* tmp = this;
+                while (tmp->prev_tab) tmp = tmp->prev_tab;
+                return *tmp;
+            }
 
 
-        bool isContainer() const { return children[0] != NULL; }
+            void setActive()
+            {
+                active = true;
+                for (Dock* tmp = prev_tab; tmp; tmp = tmp->prev_tab) tmp->active = false;
+                for (Dock* tmp = next_tab; tmp; tmp = tmp->next_tab) tmp->active = false;
+            }
 
 
-        void setChildrenPosSize(const ImVec2& _pos, const ImVec2& _size)
-        {
-            ImVec2 s = children[0]->size;
-            if (isHorizontal())
+            bool isContainer() const { return children[0] != NULL; }
+
+
+            void setChildrenPosSize(const ImVec2& _pos, const ImVec2& _size)
             {
-                s.y = _size.y;
-                s.x = (float)int(
-                            _size.x * children[0]->size.x / (children[0]->size.x + children[1]->size.x));
-                if (s.x < children[0]->getMinSize().x)
+                ImVec2 s = children[0]->size;
+                if (isHorizontal())
                 {
-                    s.x = children[0]->getMinSize().x;
+                    s.y = _size.y;
+                    s.x = (float)int(
+                        _size.x * children[0]->size.x / (children[0]->size.x + children[1]->size.x));
+                    if (s.x < children[0]->getMinSize().x)
+                    {
+                        s.x = children[0]->getMinSize().x;
+                    }
+                    else if (_size.x - s.x < children[1]->getMinSize().x)
+                    {
+                        s.x = _size.x - children[1]->getMinSize().x;
+                    }
+                    children[0]->setPosSize(_pos, s);
+
+                    s.x = _size.x - children[0]->size.x;
+                    ImVec2 p = _pos;
+                    p.x += children[0]->size.x;
+                    children[1]->setPosSize(p, s);
                 }
-                else if (_size.x - s.x < children[1]->getMinSize().x)
+                else
                 {
-                    s.x = _size.x - children[1]->getMinSize().x;
-                }
-                children[0]->setPosSize(_pos, s);
+                    s.x = _size.x;
+                    s.y = (float)int(
+                        _size.y * children[0]->size.y / (children[0]->size.y + children[1]->size.y));
+                    if (s.y < children[0]->getMinSize().y)
+                    {
+                        s.y = children[0]->getMinSize().y;
+                    }
+                    else if (_size.y - s.y < children[1]->getMinSize().y)
+                    {
+                        s.y = _size.y - children[1]->getMinSize().y;
+                    }
+                    children[0]->setPosSize(_pos, s);
 
-                s.x = _size.x - children[0]->size.x;
-                ImVec2 p = _pos;
-                p.x += children[0]->size.x;
-                children[1]->setPosSize(p, s);
+                    s.y = _size.y - children[0]->size.y;
+                    ImVec2 p = _pos;
+                    p.y += children[0]->size.y;
+                    children[1]->setPosSize(p, s);
+                }
             }
-            else
+
+
+            void setPosSize(const ImVec2& _pos, const ImVec2& _size)
             {
-                s.x = _size.x;
-                s.y = (float)int(
-                            _size.y * children[0]->size.y / (children[0]->size.y + children[1]->size.y));
-                if (s.y < children[0]->getMinSize().y)
+                size = _size;
+                pos = _pos;
+                for (Dock* tmp = prev_tab; tmp; tmp = tmp->prev_tab)
                 {
-                    s.y = children[0]->getMinSize().y;
+                    tmp->size = _size;
+                    tmp->pos = _pos;
                 }
-                else if (_size.y - s.y < children[1]->getMinSize().y)
+                for (Dock* tmp = next_tab; tmp; tmp = tmp->next_tab)
                 {
-                    s.y = _size.y - children[1]->getMinSize().y;
+                    tmp->size = _size;
+                    tmp->pos = _pos;
                 }
-                children[0]->setPosSize(_pos, s);
 
-                s.y = _size.y - children[0]->size.y;
-                ImVec2 p = _pos;
-                p.y += children[0]->size.y;
-                children[1]->setPosSize(p, s);
+                if (!isContainer()) return;
+                setChildrenPosSize(_pos, _size);
             }
+
+
+            char* label;
+            ImU32 id;
+            Dock* next_tab;
+            Dock* prev_tab;
+            Dock* children[2];
+            Dock* parent;
+            bool active;
+            ImVec2 pos;
+            ImVec2 size;
+            Status_ status;
+            int last_frame;
+            int invalid_frames;
+            char location[16];
+            bool opened;
+            bool first;
+            ImGuiWindowFlags extra_flags;
+        };
+
+
+        ImVector<Dock*> m_docks;
+        ImVec2 m_drag_offset;
+        Dock* m_current;
+        Dock *m_next_parent;
+        int m_last_frame;
+        EndAction_ m_end_action;
+        ImVec2 m_workspace_pos;
+        ImVec2 m_workspace_size;
+        uint32_t m_next_dock_slot;
+        ImVec2 m_splitSize;
+
+        DockContext()
+            : m_current(NULL)
+            , m_next_parent(NULL)
+            , m_last_frame(0)
+            , m_next_dock_slot(ImGuiDockSlot_Tab)
+            , m_splitSize(3.0f, 3.0f)
+        {
         }
 
 
-        void setPosSize(const ImVec2& _pos, const ImVec2& _size)
+        ~DockContext() {
+            ShutdownDock();//New
+        }
+
+        Dock& getDock(const char* label, bool opened, const ImVec2& default_size, ImGuiWindowFlags extra_flags)
         {
-            size = _size;
-            pos = _pos;
-            for (Dock* tmp = prev_tab; tmp; tmp = tmp->prev_tab)
+            ImU32 id = ImHash(label, 0);
+            for (int i = 0; i < m_docks.size(); ++i)
             {
-                tmp->size = _size;
-                tmp->pos = _pos;
-            }
-            for (Dock* tmp = next_tab; tmp; tmp = tmp->next_tab)
-            {
-                tmp->size = _size;
-                tmp->pos = _pos;
+                if (m_docks[i]->id == id) return *m_docks[i];
             }
 
-            if (!isContainer()) return;
-            setChildrenPosSize(_pos, _size);
+            Dock* new_dock = (Dock*)MemAlloc(sizeof(Dock));
+            IM_PLACEMENT_NEW(new_dock) Dock(extra_flags);
+            m_docks.push_back(new_dock);
+            new_dock->label = ImStrdup(label);
+            IM_ASSERT(new_dock->label);
+            new_dock->id = id;
+            new_dock->setActive();
+            new_dock->status = (m_docks.size() == 1) ? Status_Docked : Status_Float;
+            new_dock->pos = ImVec2(0, 0);
+            //new_dock->size = GetIO().DisplaySize;
+            new_dock->size.x = default_size.x < 0 ? GetIO().DisplaySize.x : default_size.x;
+            new_dock->size.y = default_size.y < 0 ? GetIO().DisplaySize.y : default_size.y;
+            new_dock->opened = opened;
+            new_dock->first = true;
+            new_dock->last_frame = 0;
+            new_dock->invalid_frames = 0;
+            new_dock->location[0] = 0;
+            return *new_dock;
         }
 
 
-        char* label;
-        ImU32 id;
-        Dock* next_tab;
-        Dock* prev_tab;
-        Dock* children[2];
-        Dock* parent;
-        bool active;
-        ImVec2 pos;
-        ImVec2 size;
-        Status_ status;
-        int last_frame;
-        int invalid_frames;
-        char location[16];
-        bool opened;
-        bool first;
-    };
+        void putInBackground()
+        {
+            ImGuiWindow* win = GetCurrentWindow();
+            ImGuiContext& g = *GImGui;
+            if (g.Windows[0] == win) return;
 
+            for (int i = 0; i < g.Windows.Size; i++)
+            {
+                if (g.Windows[i] == win)
+                {
+                    for (int j = i - 1; j >= 0; --j)
+                    {
+                        g.Windows[j + 1] = g.Windows[j];
+                    }
+                    g.Windows[0] = win;
+                    break;
+                }
+            }
+        }
 
-    ImVector<Dock*> m_docks;
-    ImVec2 m_drag_offset;
-    Dock* m_current;
-    Dock *m_next_parent;
-    int m_last_frame;
-    EndAction_ m_end_action;
-    ImVec2 m_workspace_pos;
-    ImVec2 m_workspace_size;
-    ImGuiDockSlot m_next_dock_slot;
-
-    DockContext()
-        : m_current(NULL)
-        , m_next_parent(NULL)
-        , m_last_frame(0)
-        , m_next_dock_slot(ImGuiDockSlot_Tab)
-    {
-    }
 
+        void splits()
+        {
+            if (GetFrameCount() == m_last_frame) return;
+            m_last_frame = GetFrameCount();
 
-    ~DockContext() {
-	ShutdownDock();//New
-    }
+            putInBackground();
 
-    Dock& getDock(const char* label, bool opened, const ImVec2& default_size)
-    {
-        ImU32 id = ImHash(label, 0);
-        for (int i = 0; i < m_docks.size(); ++i)
-        {
-            if (m_docks[i]->id == id) return *m_docks[i];
-        }
+            for (int i = 0; i < m_docks.size(); ++i) {
+                Dock& dock = *m_docks[i];
+                if (!dock.parent && (dock.status == Status_Docked)) {
+                    dock.setPosSize(m_workspace_pos, m_workspace_size);
+                }
+            }
 
-        Dock* new_dock = (Dock*)MemAlloc(sizeof(Dock));
-        IM_PLACEMENT_NEW(new_dock) Dock();
-        m_docks.push_back(new_dock);
-        new_dock->label = ImStrdup(label);
-        IM_ASSERT(new_dock->label);
-        new_dock->id = id;
-        new_dock->setActive();
-        new_dock->status = (m_docks.size() == 1)?Status_Docked:Status_Float;
-        new_dock->pos = ImVec2(0, 0);
-	//new_dock->size = GetIO().DisplaySize;
-	new_dock->size.x = default_size.x < 0 ? GetIO().DisplaySize.x : default_size.x;
-	new_dock->size.y = default_size.y < 0 ? GetIO().DisplaySize.y : default_size.y;
-        new_dock->opened = opened;
-        new_dock->first = true;
-        new_dock->last_frame = 0;
-        new_dock->invalid_frames = 0;
-        new_dock->location[0] = 0;
-        return *new_dock;
-    }
+            ImU32 color = GetColorU32(ImGuiCol_Button);
+            ImU32 color_hovered = GetColorU32(ImGuiCol_ButtonHovered);
+            ImDrawList* draw_list = GetWindowDrawList();
+            ImGuiIO& io = GetIO();
+            for (int i = 0; i < m_docks.size(); ++i)
+            {
+                Dock& dock = *m_docks[i];
+                if (!dock.isContainer()) continue;
 
+                PushID(i);
+                if (!IsMouseDown(0)) dock.status = Status_Docked;
 
-    void putInBackground()
-    {
-        ImGuiWindow* win = GetCurrentWindow();
-        ImGuiContext& g = *GImGui;
-        if (g.Windows[0] == win) return;
+                ImVec2 pos0 = dock.children[0]->pos;
+                ImVec2 pos1 = dock.children[1]->pos;
+                ImVec2 size0 = dock.children[0]->size;
+                ImVec2 size1 = dock.children[1]->size;
 
-        for (int i = 0; i < g.Windows.Size; i++)
-        {
-            if (g.Windows[i] == win)
-            {
-                for (int j = i - 1; j >= 0; --j)
+                ImGuiMouseCursor cursor;
+
+                ImVec2 dsize(0, 0);
+                ImVec2 min_size0 = dock.children[0]->getMinSize();
+                ImVec2 min_size1 = dock.children[1]->getMinSize();
+                if (dock.isHorizontal())
                 {
-                    g.Windows[j + 1] = g.Windows[j];
+                    cursor = ImGuiMouseCursor_ResizeEW;
+                    SetCursorScreenPos(ImVec2(dock.pos.x + size0.x - m_splitSize.x * 0.5f + 1.0f, dock.pos.y));
+                    InvisibleButton("split", ImVec2(m_splitSize.x, dock.size.y));
+                    if (dock.status == Status_Dragged) dsize.x = io.MouseDelta.x;
+                    dsize.x = -ImMin(-dsize.x, dock.children[0]->size.x - min_size0.x);
+                    dsize.x = ImMin(dsize.x, dock.children[1]->size.x - min_size1.x);
+                    size0 += dsize;
+                    size1 -= dsize;
+                    pos0 = dock.pos;
+                    pos1.x = pos0.x + size0.x;
+                    pos1.y = dock.pos.y;
+                    size0.y = size1.y = dock.size.y;
+                    size1.x = ImMax(min_size1.x, dock.size.x - size0.x);
+                    size0.x = ImMax(min_size0.x, dock.size.x - size1.x);
                 }
-                g.Windows[0] = win;
-                break;
-            }
-        }
-    }
+                else
+                {
+                    cursor = ImGuiMouseCursor_ResizeNS;
+                    SetCursorScreenPos(ImVec2(dock.pos.x, dock.pos.y + size0.y - m_splitSize.y * 0.5f + 1.0f));
+                    InvisibleButton("split", ImVec2(dock.size.x, m_splitSize.y));
+                    if (dock.status == Status_Dragged) dsize.y = io.MouseDelta.y;
+                    dsize.y = -ImMin(-dsize.y, dock.children[0]->size.y - min_size0.y);
+                    dsize.y = ImMin(dsize.y, dock.children[1]->size.y - min_size1.y);
+                    size0 += dsize;
+                    size1 -= dsize;
+                    pos0 = dock.pos;
+                    pos1.x = dock.pos.x;
+                    pos1.y = pos0.y + size0.y;
+                    size0.x = size1.x = dock.size.x;
+                    size1.y = ImMax(min_size1.y, dock.size.y - size0.y);
+                    size0.y = ImMax(min_size0.y, dock.size.y - size1.y);
+                }
+                dock.children[0]->setPosSize(pos0, size0);
+                dock.children[1]->setPosSize(pos1, size1);
 
+                if (IsItemHovered()) {
+                    SetMouseCursor(cursor);
+                }
 
-    void splits()
-    {
-        if (GetFrameCount() == m_last_frame) return;
-        m_last_frame = GetFrameCount();
+                if (IsItemHovered() && IsMouseClicked(0))
+                {
+                    if (!(dock.extra_flags & ImGuiWindowFlags_NoMove))
+                    {
+                        dock.status = Status_Dragged;
+                    }
+                }
 
-        putInBackground();
-        
-        for (int i = 0; i < m_docks.size(); ++i) {
-            Dock& dock = *m_docks[i];
-            if (!dock.parent && (dock.status == Status_Docked)) {
-                dock.setPosSize(m_workspace_pos, m_workspace_size);
+                draw_list->AddRectFilled(
+                    GetItemRectMin(), GetItemRectMax(), IsItemHovered() ? color_hovered : color);
+                PopID();
             }
         }
 
-        ImU32 color = GetColorU32(ImGuiCol_Button);
-        ImU32 color_hovered = GetColorU32(ImGuiCol_ButtonHovered);
-        ImDrawList* draw_list = GetWindowDrawList();
-        ImGuiIO& io = GetIO();
-        for (int i = 0; i < m_docks.size(); ++i)
-        {
-            Dock& dock = *m_docks[i];
-            if (!dock.isContainer()) continue;
-
-            PushID(i);
-            if (!IsMouseDown(0)) dock.status = Status_Docked;
-            
-            ImVec2 pos0 = dock.children[0]->pos;
-            ImVec2 pos1 = dock.children[1]->pos;
-            ImVec2 size0 = dock.children[0]->size;
-            ImVec2 size1 = dock.children[1]->size;
-            
-            ImGuiMouseCursor cursor;
-
-            ImVec2 dsize(0, 0);
-            ImVec2 min_size0 = dock.children[0]->getMinSize();
-            ImVec2 min_size1 = dock.children[1]->getMinSize();
-            if (dock.isHorizontal())
-            {
-                cursor = ImGuiMouseCursor_ResizeEW;
-                SetCursorScreenPos(ImVec2(dock.pos.x + size0.x, dock.pos.y));
-                InvisibleButton("split", ImVec2(3, dock.size.y));
-                if (dock.status == Status_Dragged) dsize.x = io.MouseDelta.x;
-                dsize.x = -ImMin(-dsize.x, dock.children[0]->size.x - min_size0.x);
-                dsize.x = ImMin(dsize.x, dock.children[1]->size.x - min_size1.x);
-                size0 += dsize;
-                size1 -= dsize;
-                pos0 = dock.pos;
-                pos1.x = pos0.x + size0.x;
-                pos1.y = dock.pos.y;
-                size0.y = size1.y = dock.size.y;
-                size1.x = ImMax(min_size1.x, dock.size.x - size0.x);
-                size0.x = ImMax(min_size0.x, dock.size.x - size1.x);
-            }
-            else
-            {
-                cursor = ImGuiMouseCursor_ResizeNS;
-                SetCursorScreenPos(ImVec2(dock.pos.x, dock.pos.y + size0.y));
-                InvisibleButton("split", ImVec2(dock.size.x, 3));
-                if (dock.status == Status_Dragged) dsize.y = io.MouseDelta.y;
-                dsize.y = -ImMin(-dsize.y, dock.children[0]->size.y - min_size0.y);
-                dsize.y = ImMin(dsize.y, dock.children[1]->size.y - min_size1.y);
-                size0 += dsize;
-                size1 -= dsize;
-                pos0 = dock.pos;
-                pos1.x = dock.pos.x;
-                pos1.y = pos0.y + size0.y;
-                size0.x = size1.x = dock.size.x;
-                size1.y = ImMax(min_size1.y, dock.size.y - size0.y);
-                size0.y = ImMax(min_size0.y, dock.size.y - size1.y);
-            }
-            dock.children[0]->setPosSize(pos0, size0);
-            dock.children[1]->setPosSize(pos1, size1);
 
-            if (IsItemHovered()) {
-                SetMouseCursor(cursor);
-            }
-            
-            if (IsItemHovered() && IsMouseClicked(0))
+        void checkNonexistent()
+        {
+            int frame_limit = ImMax(0, ImGui::GetFrameCount() - 2);
+            for (int i = 0; i < m_docks.size(); ++i)
             {
-                dock.status = Status_Dragged;
+                Dock *dock = m_docks[i];
+                if (dock->isContainer()) continue;
+                if (dock->status == Status_Float) continue;
+                if (dock->last_frame < frame_limit)
+                {
+                    ++dock->invalid_frames;
+                    if (dock->invalid_frames > 2)
+                    {
+                        doUndock(*dock);
+                        dock->status = Status_Float;
+                    }
+                    return;
+                }
+                dock->invalid_frames = 0;
             }
-
-            draw_list->AddRectFilled(
-                        GetItemRectMin(), GetItemRectMax(), IsItemHovered() ? color_hovered : color);
-            PopID();
         }
-    }
 
 
-    void checkNonexistent()
-    {
-        int frame_limit = ImMax(0, ImGui::GetFrameCount() - 2);
-        for (int i = 0; i < m_docks.size(); ++i)
+        Dock* getDockAt(const ImVec2& /*pos*/) const
         {
-            Dock *dock = m_docks[i];
-            if (dock->isContainer()) continue;
-            if (dock->status == Status_Float) continue;
-            if (dock->last_frame < frame_limit)
+            for (int i = 0; i < m_docks.size(); ++i)
             {
-                ++dock->invalid_frames;
-                if (dock->invalid_frames > 2)
+                Dock& dock = *m_docks[i];
+                if (dock.isContainer()) continue;
+                if (dock.status != Status_Docked) continue;
+                if (IsMouseHoveringRect(dock.pos, dock.pos + dock.size, false))
                 {
-                    doUndock(*dock);
-                    dock->status = Status_Float;
+                    return &dock;
                 }
-                return;
             }
-            dock->invalid_frames = 0;
+
+            return NULL;
         }
-    }
 
 
-    Dock* getDockAt(const ImVec2& /*pos*/) const
-    {
-        for (int i = 0; i < m_docks.size(); ++i)
+        static ImRect getDockedRect(const ImRect& rect, ImGuiDockSlot dock_slot)
         {
-            Dock& dock = *m_docks[i];
-            if (dock.isContainer()) continue;
-            if (dock.status != Status_Docked) continue;
-            if (IsMouseHoveringRect(dock.pos, dock.pos + dock.size, false))
+            ImVec2 half_size = rect.GetSize() * 0.5f;
+            switch (dock_slot)
             {
-                return &dock;
+            default: return rect;
+                //case ImGuiDockSlot_Top: return ImRect(rect.Min, ImVec2(rect.Max.x, rect.Min.y + half_size.y));	  //  original
+            case ImGuiDockSlot_Top: return ImRect(rect.Min, rect.Min + ImVec2(rect.Max.x - rect.Min.x, half_size.y)); //  @r-lyeh
+            case ImGuiDockSlot_Right: return ImRect(rect.Min + ImVec2(half_size.x, 0), rect.Max);
+            case ImGuiDockSlot_Bottom: return ImRect(rect.Min + ImVec2(0, half_size.y), rect.Max);
+            case ImGuiDockSlot_Left: return ImRect(rect.Min, ImVec2(rect.Min.x + half_size.x, rect.Max.y));
             }
         }
 
-        return NULL;
-    }
-
-
-    static ImRect getDockedRect(const ImRect& rect, ImGuiDockSlot dock_slot)
-    {
-        ImVec2 half_size = rect.GetSize() * 0.5f;
-        switch (dock_slot)
-        {
-        default: return rect;
-	//case ImGuiDockSlot_Top: return ImRect(rect.Min, ImVec2(rect.Max.x, rect.Min.y + half_size.y));	  //  original
-	case ImGuiDockSlot_Top: return ImRect(rect.Min, rect.Min + ImVec2(rect.Max.x - rect.Min.x, half_size.y)); //  @r-lyeh
-        case ImGuiDockSlot_Right: return ImRect(rect.Min + ImVec2(half_size.x, 0), rect.Max);
-        case ImGuiDockSlot_Bottom: return ImRect(rect.Min + ImVec2(0, half_size.y), rect.Max);
-        case ImGuiDockSlot_Left: return ImRect(rect.Min, ImVec2(rect.Min.x + half_size.x, rect.Max.y));
-        }
-    }
-
 
-    static ImRect getSlotRect(ImRect parent_rect, ImGuiDockSlot dock_slot)
-    {
-        ImVec2 size = parent_rect.Max - parent_rect.Min;
-        ImVec2 center = parent_rect.Min + size * 0.5f;
-        switch (dock_slot)
+        static ImRect getSlotRect(ImRect parent_rect, ImGuiDockSlot dock_slot)
         {
-        default: return ImRect(center - ImVec2(20, 20), center + ImVec2(20, 20));
-        case ImGuiDockSlot_Top: return ImRect(center + ImVec2(-20, -50), center + ImVec2(20, -30));
-        case ImGuiDockSlot_Right: return ImRect(center + ImVec2(30, -20), center + ImVec2(50, 20));
-        case ImGuiDockSlot_Bottom: return ImRect(center + ImVec2(-20, +30), center + ImVec2(20, 50));
-        case ImGuiDockSlot_Left: return ImRect(center + ImVec2(-50, -20), center + ImVec2(-30, 20));
+            ImVec2 size = parent_rect.Max - parent_rect.Min;
+            ImVec2 center = parent_rect.Min + size * 0.5f;
+            switch (dock_slot)
+            {
+            default: return ImRect(center - ImVec2(20, 20), center + ImVec2(20, 20));
+            case ImGuiDockSlot_Top: return ImRect(center + ImVec2(-20, -50), center + ImVec2(20, -30));
+            case ImGuiDockSlot_Right: return ImRect(center + ImVec2(30, -20), center + ImVec2(50, 20));
+            case ImGuiDockSlot_Bottom: return ImRect(center + ImVec2(-20, +30), center + ImVec2(20, 50));
+            case ImGuiDockSlot_Left: return ImRect(center + ImVec2(-50, -20), center + ImVec2(-30, 20));
+            }
         }
-    }
 
 
-    static ImRect getSlotRectOnBorder(ImRect parent_rect, ImGuiDockSlot dock_slot)
-    {
-        ImVec2 size = parent_rect.Max - parent_rect.Min;
-        ImVec2 center = parent_rect.Min + size * 0.5f;
-        switch (dock_slot)
+        static ImRect getSlotRectOnBorder(ImRect parent_rect, ImGuiDockSlot dock_slot)
         {
-        case ImGuiDockSlot_Top:
-            return ImRect(ImVec2(center.x - 20, parent_rect.Min.y + 10),
-                          ImVec2(center.x + 20, parent_rect.Min.y + 30));
-        case ImGuiDockSlot_Left:
-            return ImRect(ImVec2(parent_rect.Min.x + 10, center.y - 20),
-                          ImVec2(parent_rect.Min.x + 30, center.y + 20));
-        case ImGuiDockSlot_Bottom:
-            return ImRect(ImVec2(center.x - 20, parent_rect.Max.y - 30),
-                          ImVec2(center.x + 20, parent_rect.Max.y - 10));
-        case ImGuiDockSlot_Right:
-            return ImRect(ImVec2(parent_rect.Max.x - 30, center.y - 20),
-                          ImVec2(parent_rect.Max.x - 10, center.y + 20));
-        default: IM_ASSERT(false);
+            ImVec2 size = parent_rect.Max - parent_rect.Min;
+            ImVec2 center = parent_rect.Min + size * 0.5f;
+            switch (dock_slot)
+            {
+            case ImGuiDockSlot_Top:
+                return ImRect(ImVec2(center.x - 20, parent_rect.Min.y + 10),
+                    ImVec2(center.x + 20, parent_rect.Min.y + 30));
+            case ImGuiDockSlot_Left:
+                return ImRect(ImVec2(parent_rect.Min.x + 10, center.y - 20),
+                    ImVec2(parent_rect.Min.x + 30, center.y + 20));
+            case ImGuiDockSlot_Bottom:
+                return ImRect(ImVec2(center.x - 20, parent_rect.Max.y - 30),
+                    ImVec2(center.x + 20, parent_rect.Max.y - 10));
+            case ImGuiDockSlot_Right:
+                return ImRect(ImVec2(parent_rect.Max.x - 30, center.y - 20),
+                    ImVec2(parent_rect.Max.x - 10, center.y + 20));
+            default: IM_ASSERT(false);
+            }
+            IM_ASSERT(false);
+            return ImRect();
         }
-        IM_ASSERT(false);
-        return ImRect();
-    }
 
 
-    Dock* getRootDock()
-    {
-        for (int i = 0; i < m_docks.size(); ++i)
+        Dock* getRootDock()
         {
-            if (!m_docks[i]->parent &&
-                    (m_docks[i]->status == Status_Docked || m_docks[i]->children[0]))
+            for (int i = 0; i < m_docks.size(); ++i)
             {
-                return m_docks[i];
+                if (!m_docks[i]->parent &&
+                    (m_docks[i]->status == Status_Docked || m_docks[i]->children[0]))
+                {
+                    return m_docks[i];
+                }
             }
+            return NULL;
         }
-        return NULL;
-    }
 
 
-    bool dockSlots(Dock& dock, Dock* dest_dock, const ImRect& rect, bool on_border)
-    {
-        ImDrawList* canvas = GetWindowDrawList();
-	ImU32 color = GetColorU32(ImGuiCol_Button);		    // Color of all the available "spots"
-	ImU32 color_hovered = GetColorU32(ImGuiCol_ButtonHovered);  // Color of the hovered "spot"
-	ImU32 docked_rect_color = color;
-	ImVec2 mouse_pos = GetIO().MousePos;
-	ImTextureID texture = NULL;
-	if (gImGuiDockReuseTabWindowTextureIfAvailable)	{
+        bool dockSlots(Dock& dock, Dock* dest_dock, const ImRect& rect, bool on_border)
+        {
+            ImDrawList* canvas = GetWindowDrawList();
+            ImU32 color = GetColorU32(ImGuiCol_Button);		    // Color of all the available "spots"
+            ImU32 color_hovered = GetColorU32(ImGuiCol_ButtonHovered);  // Color of the hovered "spot"
+            ImU32 docked_rect_color = color;
+            ImVec2 mouse_pos = GetIO().MousePos;
+            ImTextureID texture = NULL;
+            if (gImGuiDockReuseTabWindowTextureIfAvailable) {
 #	ifdef IMGUITABWINDOW_H_
-	texture = ImGui::TabWindow::DockPanelIconTextureID;	// Nope. It doesn't look OK.
-	if (texture) {
-	    color = 0x00FFFFFF | 0x90000000;
-	    color_hovered = (color_hovered & 0x00FFFFFF) | 0x90000000;
-	    docked_rect_color = (docked_rect_color &  0x00FFFFFF) | 0x80000000;
-
-	    canvas->ChannelsSplit(2);	// Solves overlay order. But won't it break something else ?
-	}
+                texture = ImGui::TabWindow::DockPanelIconTextureID;	// Nope. It doesn't look OK.
+                if (texture) {
+                    color = 0x00FFFFFF | 0x90000000;
+                    color_hovered = (color_hovered & 0x00FFFFFF) | 0x90000000;
+                    docked_rect_color = (docked_rect_color & 0x00FFFFFF) | 0x80000000;
+
+                    canvas->ChannelsSplit(2);	// Solves overlay order. But won't it break something else ?
+                }
 #	endif ////IMGUITABWINDOW_H_
-	}
-        for (int i = 0; i < (on_border ? 4 : 5); ++i)
-        {
-	    const ImGuiDockSlot iSlot = (ImGuiDockSlot)i;
-            ImRect r =
-		    on_border ? getSlotRectOnBorder(rect, iSlot) : getSlotRect(rect, iSlot);
-            bool hovered = r.Contains(mouse_pos);
-	    ImU32 color_to_use = hovered ? color_hovered : color;
-	    if (!texture) canvas->AddRectFilled(r.Min, r.Max, color_to_use);
-	    else {
+            }
+            for (int i = 0; i < (on_border ? 4 : 5); ++i)
+            {
+                const ImGuiDockSlot iSlot = SlotIndex[i];
+                ImRect r =
+                    on_border ? getSlotRectOnBorder(rect, iSlot) : getSlotRect(rect, iSlot);
+                bool hovered = r.Contains(mouse_pos);
+                ImU32 color_to_use = hovered ? color_hovered : color;
+                if (!texture) canvas->AddRectFilled(r.Min, r.Max, color_to_use);
+                else {
 #		ifdef IMGUITABWINDOW_H_
-		canvas->ChannelsSetCurrent(0);	// Background
-		switch (iSlot)	{
-		case ImGuiDockSlot_Left:
-		case ImGuiDockSlot_Right:
-		case ImGuiDockSlot_Top:
-		case ImGuiDockSlot_Bottom:
-		{
-		    const int uvIndex = (i==0)?3:(i==2)?0:(i==3)?2:i;
-		    ImVec2 uv0(0.75f,(float)uvIndex*0.25f),uv1(uv0.x+0.25f,uv0.y+0.25f);
-		    canvas->AddImage(texture,r.Min, r.Max,uv0,uv1,color_to_use);
-		}
-		break;
-		case ImGuiDockSlot_Tab:
-		    canvas->AddImage(texture,r.Min, r.Max,ImVec2(0.22916f,0.22916f),ImVec2(0.45834f,0.45834f),color_to_use);
-		break;
-		default:
-		    canvas->AddRectFilled(r.Min, r.Max, color_to_use);
-		break;
-		}
-		canvas->ChannelsSetCurrent(1);	// Foreground
+                    canvas->ChannelsSetCurrent(0);	// Background
+                    switch (iSlot) {
+                    case ImGuiDockSlot_Left:
+                    case ImGuiDockSlot_Right:
+                    case ImGuiDockSlot_Top:
+                    case ImGuiDockSlot_Bottom:
+                    {
+                        const int uvIndex = (i == 0) ? 3 : (i == 2) ? 0 : (i == 3) ? 2 : i;
+                        ImVec2 uv0(0.75f, (float)uvIndex*0.25f), uv1(uv0.x + 0.25f, uv0.y + 0.25f);
+                        canvas->AddImage(texture, r.Min, r.Max, uv0, uv1, color_to_use);
+                    }
+                    break;
+                    case ImGuiDockSlot_Tab:
+                        canvas->AddImage(texture, r.Min, r.Max, ImVec2(0.22916f, 0.22916f), ImVec2(0.45834f, 0.45834f), color_to_use);
+                        break;
+                    default:
+                        canvas->AddRectFilled(r.Min, r.Max, color_to_use);
+                        break;
+                    }
+                    canvas->ChannelsSetCurrent(1);	// Foreground
 #		endif ////IMGUITABWINDOW_H_
-	    }
-            if (!hovered) continue;
+                }
+                if (!hovered) continue;
 
-            if (!IsMouseDown(0))
-            {
+                if (!IsMouseDown(0))
+                {
 #		ifdef IMGUITABWINDOW_H_
-		if (texture) canvas->ChannelsMerge();
+                    if (texture) canvas->ChannelsMerge();
 #		endif ////IMGUITABWINDOW_H_
-		doDock(dock, dest_dock ? dest_dock : getRootDock(), iSlot);
-                return true;
+                    doDock(dock, dest_dock ? dest_dock : getRootDock(), iSlot);
+                    return true;
+                }
+                ImRect docked_rect = getDockedRect(rect, iSlot);
+                canvas->AddRectFilled(docked_rect.Min, docked_rect.Max, docked_rect_color);
             }
-	    ImRect docked_rect = getDockedRect(rect, iSlot);
-	    canvas->AddRectFilled(docked_rect.Min, docked_rect.Max, docked_rect_color);
-        }
 #	ifdef IMGUITABWINDOW_H_
-	if (texture) canvas->ChannelsMerge();
+            if (texture) canvas->ChannelsMerge();
 #	endif ////IMGUITABWINDOW_H_
-	return false;
-    }
+            return false;
+        }
 
 
-    void handleDrag(Dock& dock)
-    {
-        Dock* dest_dock = getDockAt(GetIO().MousePos);
-
-        Begin("##Overlay",
-              NULL,
-              ImVec2(0, 0),
-              0.f,
-              ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove |
-              ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings |
-              ImGuiWindowFlags_AlwaysAutoResize);
-        ImDrawList* canvas = GetWindowDrawList();
-
-        canvas->PushClipRectFullScreen();
-
-        ImU32 docked_color = GetColorU32(ImGuiCol_FrameBg);
-	docked_color = (docked_color & 0x00ffFFFF) | 0x80000000;
-        dock.pos = GetIO().MousePos - m_drag_offset;
-        if (dest_dock)
+        void handleDrag(Dock& dock)
         {
-            if (dockSlots(dock,
-                          dest_dock,
-                          ImRect(dest_dock->pos, dest_dock->pos + dest_dock->size),
-                          false))
+            Dock* dest_dock = getDockAt(GetIO().MousePos);
+
+            Begin("##Overlay",
+                NULL,
+                ImVec2(0, 0),
+                0.f,
+                ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove |
+                ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings |
+                ImGuiWindowFlags_AlwaysAutoResize);
+            ImDrawList* canvas = GetWindowDrawList();
+
+            canvas->PushClipRectFullScreen();
+
+            ImU32 docked_color = GetColorU32(ImGuiCol_FrameBg);
+            docked_color = (docked_color & 0x00ffFFFF) | 0x80000000;
+            dock.pos = GetIO().MousePos - m_drag_offset;
+            if (dest_dock)
+            {
+                if (dockSlots(dock,
+                    dest_dock,
+                    ImRect(dest_dock->pos, dest_dock->pos + dest_dock->size),
+                    false))
+                {
+                    canvas->PopClipRect();
+                    End();
+                    return;
+                }
+            }
+            if (dockSlots(dock, NULL, ImRect(m_workspace_pos, m_workspace_pos + m_workspace_size), true))
             {
                 canvas->PopClipRect();
                 End();
                 return;
             }
-        }
-        if (dockSlots(dock, NULL, ImRect(m_workspace_pos, m_workspace_pos + m_workspace_size), true))
-        {
+            canvas->AddRectFilled(dock.pos, dock.pos + dock.size, docked_color);
             canvas->PopClipRect();
-            End();
-            return;
-        }
-        canvas->AddRectFilled(dock.pos, dock.pos + dock.size, docked_color);
-        canvas->PopClipRect();
 
-        if (!IsMouseDown(0))
-        {
-            dock.status = Status_Float;
-            dock.location[0] = 0;
-            dock.setActive();
-        }
+            if (!IsMouseDown(0))
+            {
+                dock.status = Status_Float;
+                dock.location[0] = 0;
+                dock.setActive();
+            }
 
-        End();
-    }
+            End();
+        }
 
 
-    void fillLocation(Dock& dock)
-    {
-        if (dock.status == Status_Float) return;
-        char* c = dock.location;
-        Dock* tmp = &dock;
-        while (tmp->parent)
+        void fillLocation(Dock& dock)
         {
-            *c = getLocationCode(tmp);
-            tmp = tmp->parent;
-            ++c;
+            if (dock.status == Status_Float) return;
+            char* c = dock.location;
+            Dock* tmp = &dock;
+            while (tmp->parent)
+            {
+                *c = getLocationCode(tmp);
+                tmp = tmp->parent;
+                ++c;
+            }
+            *c = 0;
         }
-        *c = 0;
-    }
 
 
-    void doUndock(Dock& dock)
-    {
-        if (dock.prev_tab)
-            dock.prev_tab->setActive();
-        else if (dock.next_tab)
-            dock.next_tab->setActive();
-        else
-            dock.active = false;
-        Dock* container = dock.parent;
-
-        if (container)
+        void doUndock(Dock& dock)
         {
-            Dock& sibling = dock.getSibling();
-            if (container->children[0] == &dock)
-            {
-                container->children[0] = dock.next_tab;
-            }
-            else if (container->children[1] == &dock)
-            {
-                container->children[1] = dock.next_tab;
-            }
+            if (dock.prev_tab)
+                dock.prev_tab->setActive();
+            else if (dock.next_tab)
+                dock.next_tab->setActive();
+            else
+                dock.active = false;
+            Dock* container = dock.parent;
 
-            bool remove_container = !container->children[0] || !container->children[1];
-            if (remove_container)
+            if (container)
             {
-                if (container->parent)
+                Dock& sibling = dock.getSibling();
+                if (container->children[0] == &dock)
                 {
-                    Dock*& child = container->parent->children[0] == container
-                            ? container->parent->children[0]
-                            : container->parent->children[1];
-                    child = &sibling;
-                    child->setPosSize(container->pos, container->size);
-                    child->setParent(container->parent);
+                    container->children[0] = dock.next_tab;
                 }
-                else
+                else if (container->children[1] == &dock)
+                {
+                    container->children[1] = dock.next_tab;
+                }
+
+                bool remove_container = !container->children[0] || !container->children[1];
+                if (remove_container)
                 {
-                    if (container->children[0])
+                    if (container->parent)
                     {
-                        container->children[0]->setParent(NULL);
-                        container->children[0]->setPosSize(container->pos, container->size);
+                        Dock*& child = container->parent->children[0] == container
+                            ? container->parent->children[0]
+                            : container->parent->children[1];
+                        child = &sibling;
+                        child->setPosSize(container->pos, container->size);
+                        child->setParent(container->parent);
                     }
-                    if (container->children[1])
+                    else
                     {
-                        container->children[1]->setParent(NULL);
-                        container->children[1]->setPosSize(container->pos, container->size);
+                        if (container->children[0])
+                        {
+                            container->children[0]->setParent(NULL);
+                            container->children[0]->setPosSize(container->pos, container->size);
+                        }
+                        if (container->children[1])
+                        {
+                            container->children[1]->setParent(NULL);
+                            container->children[1]->setPosSize(container->pos, container->size);
+                        }
                     }
-                }
-                for (int i = 0; i < m_docks.size(); ++i)
-                {
-                    if (m_docks[i] == container)
+                    for (int i = 0; i < m_docks.size(); ++i)
                     {
-                        m_docks.erase(m_docks.begin() + i);
-                        break;
+                        if (m_docks[i] == container)
+                        {
+                            m_docks.erase(m_docks.begin() + i);
+                            break;
+                        }
                     }
+                    if (container == m_next_parent)
+                        m_next_parent = NULL;
+                    container->~Dock();
+                    MemFree(container);
                 }
-                if (container == m_next_parent)
-                    m_next_parent = NULL;
-                container->~Dock();
-                MemFree(container);
             }
+            if (dock.prev_tab) dock.prev_tab->next_tab = dock.next_tab;
+            if (dock.next_tab) dock.next_tab->prev_tab = dock.prev_tab;
+            dock.parent = NULL;
+            dock.prev_tab = dock.next_tab = NULL;
         }
-        if (dock.prev_tab) dock.prev_tab->next_tab = dock.next_tab;
-        if (dock.next_tab) dock.next_tab->prev_tab = dock.prev_tab;
-        dock.parent = NULL;
-        dock.prev_tab = dock.next_tab = NULL;
-    }
 
 
-    void drawTabbarListButton(Dock& dock)
-    {
-        if (!dock.next_tab) return;
-
-        ImDrawList* draw_list = GetWindowDrawList();
-        if (InvisibleButton("list", ImVec2(16, 16)))
-        {
-            OpenPopup("tab_list_popup");
-        }
-        if (BeginPopup("tab_list_popup"))
+        void drawTabbarListButton(Dock& dock)
         {
-            Dock* tmp = &dock;
-            while (tmp)
+            if (!dock.next_tab) return;
+
+            ImDrawList* draw_list = GetWindowDrawList();
+            if (InvisibleButton("list", ImVec2(16, 16)))
             {
-                bool dummy = false;
-                if (Selectable(tmp->label, &dummy))
+                OpenPopup("tab_list_popup");
+            }
+            if (BeginPopup("tab_list_popup"))
+            {
+                Dock* tmp = &dock;
+                while (tmp)
                 {
-                    tmp->setActive();
-                    m_next_parent = tmp;
+                    bool dummy = false;
+                    if (Selectable(tmp->label, &dummy))
+                    {
+                        tmp->setActive();
+                        m_next_parent = tmp;
+                    }
+                    tmp = tmp->next_tab;
                 }
-                tmp = tmp->next_tab;
+                EndPopup();
             }
-            EndPopup();
-        }
 
-        bool hovered = IsItemHovered();
-        ImVec2 min = GetItemRectMin();
-        ImVec2 max = GetItemRectMax();
-        ImVec2 center = (min + max) * 0.5f;
-        ImU32 text_color = GetColorU32(ImGuiCol_Text);
-        ImU32 color_active = GetColorU32(ImGuiCol_FrameBgActive);
-        draw_list->AddRectFilled(ImVec2(center.x - 4, min.y + 3),
-                                 ImVec2(center.x + 4, min.y + 5),
-                                 hovered ? color_active : text_color);
-        draw_list->AddTriangleFilled(ImVec2(center.x - 4, min.y + 7),
-                                     ImVec2(center.x + 4, min.y + 7),
-                                     ImVec2(center.x, min.y + 12),
-                                     hovered ? color_active : text_color);
-    }
+            bool hovered = IsItemHovered();
+            ImVec2 min = GetItemRectMin();
+            ImVec2 max = GetItemRectMax();
+            ImVec2 center = (min + max) * 0.5f;
+            ImU32 text_color = GetColorU32(ImGuiCol_Text);
+            ImU32 color_active = GetColorU32(ImGuiCol_FrameBgActive);
+            draw_list->AddRectFilled(ImVec2(center.x - 4, min.y + 3),
+                ImVec2(center.x + 4, min.y + 5),
+                hovered ? color_active : text_color);
+            draw_list->AddTriangleFilled(ImVec2(center.x - 4, min.y + 7),
+                ImVec2(center.x + 4, min.y + 7),
+                ImVec2(center.x, min.y + 12),
+                hovered ? color_active : text_color);
+        }
 
 
-    bool tabbar(Dock& dock, bool close_button)
-    {
-        float tabbar_height = 2 * GetTextLineHeightWithSpacing();
-        ImVec2 size(dock.size.x, tabbar_height);
-        bool tab_closed = false;
-
-        SetCursorScreenPos(dock.pos);
-        char tmp[20];
-        ImFormatString(tmp, IM_ARRAYSIZE(tmp), "tabs%d", (int)dock.id);
-        if (BeginChild(tmp, size, true))
+        bool tabbar(Dock& dock, bool close_button)
         {
-            Dock* dock_tab = &dock;
-
-            ImDrawList* draw_list = GetWindowDrawList();
-            ImU32 color = GetColorU32(ImGuiCol_FrameBg);
-            ImU32 color_active = GetColorU32(ImGuiCol_FrameBgActive);
-            ImU32 color_hovered = GetColorU32(ImGuiCol_FrameBgHovered);
-            ImU32 text_color = GetColorU32(ImGuiCol_Text);
-            float line_height = GetTextLineHeightWithSpacing();
-            float tab_base;
+            float tabbar_height = 2 * GetTextLineHeightWithSpacing();
+            ImVec2 size(dock.size.x, tabbar_height);
+            bool tab_closed = false;
+
+            SetCursorScreenPos(dock.pos);
+            char tmp[20];
+            ImFormatString(tmp, IM_ARRAYSIZE(tmp), "tabs%d", (int)dock.id);
+            if (BeginChild(tmp, size, true))
+            {
+                Dock* dock_tab = &dock;
 
-            drawTabbarListButton(dock);
+                ImDrawList* draw_list = GetWindowDrawList();
+                ImU32 color = GetColorU32(ImGuiCol_FrameBg);
+                ImU32 color_active = GetColorU32(ImGuiCol_FrameBgActive);
+                ImU32 color_hovered = GetColorU32(ImGuiCol_FrameBgHovered);
+                ImU32 text_color = GetColorU32(ImGuiCol_Text);
+                float line_height = GetTextLineHeightWithSpacing();
+                float tab_base;
 
-            while (dock_tab)
-            {
-                SameLine(0, 15);
+                drawTabbarListButton(dock);
 
-                const char* text_end = FindRenderedTextEnd(dock_tab->label);
-                ImVec2 size(CalcTextSize(dock_tab->label, text_end).x, line_height);
-                if (InvisibleButton(dock_tab->label, size))
+                while (dock_tab)
                 {
-                    dock_tab->setActive();
-                    m_next_parent = dock_tab;
-                }
+                    SameLine(0, 15);
 
-                if (IsItemActive() && IsMouseDragging())
-                {
-                    m_drag_offset = GetMousePos() - dock_tab->pos;
-                    doUndock(*dock_tab);
-                    dock_tab->status = Status_Dragged;
-                }
+                    const char* text_end = FindRenderedTextEnd(dock_tab->label);
+                    ImVec2 size(CalcTextSize(dock_tab->label, text_end).x, line_height);
+                    if (InvisibleButton(dock_tab->label, size))
+                    {
+                        dock_tab->setActive();
+                        m_next_parent = dock_tab;
+                    }
 
-                bool hovered = IsItemHovered();
-                ImVec2 pos = GetItemRectMin();
-                if (dock_tab->active && close_button)
-                {
-                    size.x += 16 + GetStyle().ItemSpacing.x;
-                    SameLine();
-                    tab_closed = InvisibleButton("close", ImVec2(16, 16));
-                    ImVec2 center = (GetItemRectMin() + GetItemRectMax()) * 0.5f;
-                    draw_list->AddLine(
-                                center + ImVec2(-3.5f, -3.5f), center + ImVec2(3.5f, 3.5f), text_color);
-                    draw_list->AddLine(
-                                center + ImVec2(3.5f, -3.5f), center + ImVec2(-3.5f, 3.5f), text_color);
+                    if (IsItemActive() && IsMouseDragging())
+                    {
+                        if (!(dock_tab->extra_flags & ImGuiWindowFlags_NoMove))
+                        {
+                            m_drag_offset = GetMousePos() - dock_tab->pos;
+                            doUndock(*dock_tab);
+                            dock_tab->status = Status_Dragged;
+                        }
+                    }
+
+                    bool hovered = IsItemHovered();
+                    ImVec2 pos = GetItemRectMin();
+                    if (dock_tab->active && close_button)
+                    {
+                        size.x += 16 + GetStyle().ItemSpacing.x;
+                        SameLine();
+                        tab_closed = InvisibleButton("close", ImVec2(16, 16));
+                        ImVec2 center = (GetItemRectMin() + GetItemRectMax()) * 0.5f;
+                        draw_list->AddLine(
+                            center + ImVec2(-3.5f, -3.5f), center + ImVec2(3.5f, 3.5f), text_color);
+                        draw_list->AddLine(
+                            center + ImVec2(3.5f, -3.5f), center + ImVec2(-3.5f, 3.5f), text_color);
+                    }
+                    tab_base = pos.y;
+                    draw_list->PathClear();
+                    draw_list->PathLineTo(pos + ImVec2(-15, size.y));
+                    draw_list->PathBezierCurveTo(
+                        pos + ImVec2(-10, size.y), pos + ImVec2(-5, 0), pos + ImVec2(0, 0), 10);
+                    draw_list->PathLineTo(pos + ImVec2(size.x, 0));
+                    draw_list->PathBezierCurveTo(pos + ImVec2(size.x + 5, 0),
+                        pos + ImVec2(size.x + 10, size.y),
+                        pos + ImVec2(size.x + 15, size.y),
+                        10);
+                    draw_list->PathFillConvex(
+                        hovered ? color_hovered : (dock_tab->active ? color_active : color));
+                    draw_list->AddText(pos + ImVec2(0, 1), text_color, dock_tab->label, text_end);
+
+                    dock_tab = dock_tab->next_tab;
                 }
-                tab_base = pos.y;
-                draw_list->PathClear();
-                draw_list->PathLineTo(pos + ImVec2(-15, size.y));
-                draw_list->PathBezierCurveTo(
-                            pos + ImVec2(-10, size.y), pos + ImVec2(-5, 0), pos + ImVec2(0, 0), 10);
-                draw_list->PathLineTo(pos + ImVec2(size.x, 0));
-                draw_list->PathBezierCurveTo(pos + ImVec2(size.x + 5, 0),
-                                             pos + ImVec2(size.x + 10, size.y),
-                                             pos + ImVec2(size.x + 15, size.y),
-                                             10);
-		draw_list->PathFillConvex(
-                            hovered ? color_hovered : (dock_tab->active ? color_active : color));
-                draw_list->AddText(pos + ImVec2(0, 1), text_color, dock_tab->label, text_end);
-
-                dock_tab = dock_tab->next_tab;
+                ImVec2 cp(dock.pos.x, tab_base + line_height);
+                draw_list->AddLine(cp, cp + ImVec2(dock.size.x, 0), color);
             }
-            ImVec2 cp(dock.pos.x, tab_base + line_height);
-            draw_list->AddLine(cp, cp + ImVec2(dock.size.x, 0), color);
+            EndChild();
+            return tab_closed;
         }
-        EndChild();
-        return tab_closed;
-    }
 
 
-    static void setDockPosSize(Dock& dest, Dock& dock, ImGuiDockSlot dock_slot, Dock& container)
-    {
-        IM_ASSERT(!dock.prev_tab && !dock.next_tab && !dock.children[0] && !dock.children[1]);
+        static void setDockPosSize(Dock& dest, Dock& dock, uint32_t dock_slot, Dock& container)
+        {
+            IM_ASSERT(!dock.prev_tab && !dock.next_tab && !dock.children[0] && !dock.children[1]);
 
-        dest.pos = container.pos;
-        dest.size = container.size;
-        dock.pos = container.pos;
-        dock.size = container.size;
+            dest.pos = container.pos;
+            dest.size = container.size;
+            dock.pos = container.pos;
+            dock.size = container.size;
 
-        switch (dock_slot)
-        {
-        case ImGuiDockSlot_Bottom:
-            dest.size.y *= 0.5f;
-            dock.size.y *= 0.5f;
-            dock.pos.y += dest.size.y;
-            break;
-        case ImGuiDockSlot_Right:
-            dest.size.x *= 0.5f;
-            dock.size.x *= 0.5f;
-            dock.pos.x += dest.size.x;
-            break;
-        case ImGuiDockSlot_Left:
-            dest.size.x *= 0.5f;
-            dock.size.x *= 0.5f;
-            dest.pos.x += dock.size.x;
-            break;
-        case ImGuiDockSlot_Top:
-            dest.size.y *= 0.5f;
-            dock.size.y *= 0.5f;
-            dest.pos.y += dock.size.y;
-            break;
-        default: IM_ASSERT(false); break;
-        }
-        dest.setPosSize(dest.pos, dest.size);
+            if (dock_slot & ImGuiDockSlot_Bottom)
+            {
+                dest.size.y *= 0.5f;
+                dock.size.y *= 0.5f;
+                dock.pos.y += dest.size.y;
+            }
+            else if (dock_slot & ImGuiDockSlot_Right)
+            {
+                dest.size.x *= 0.5f;
+                dock.size.x *= 0.5f;
+                dock.pos.x += dest.size.x;
+            }
+            else if (dock_slot & ImGuiDockSlot_Left)
+            {
+                dest.size.x *= 0.5f;
+                dock.size.x *= 0.5f;
+                dest.pos.x += dock.size.x;
+            }
+            else if (dock_slot & ImGuiDockSlot_Top)
+            {
+                dest.size.y *= 0.5f;
+                dock.size.y *= 0.5f;
+                dest.pos.y += dock.size.y;
+            }
 
-        if (container.children[1]->pos.x < container.children[0]->pos.x ||
+            dest.setPosSize(dest.pos, dest.size);
+            if (container.children[1]->pos.x < container.children[0]->pos.x ||
                 container.children[1]->pos.y < container.children[0]->pos.y)
-        {
-            Dock* tmp = container.children[0];
-            container.children[0] = container.children[1];
-            container.children[1] = tmp;
+            {
+                Dock* tmp = container.children[0];
+                container.children[0] = container.children[1];
+                container.children[1] = tmp;
+            }
         }
-    }
 
 
-    void doDock(Dock& dock, Dock* dest, ImGuiDockSlot dock_slot)
-    {
-        IM_ASSERT(!dock.parent);
-        if (!dest)
-        {
-            dock.status = Status_Docked;
-            dock.setPosSize(m_workspace_pos, m_workspace_size);
-        }
-        else if (dock_slot == ImGuiDockSlot_Tab)
+        void doDock(Dock& dock, Dock* dest, uint32_t dock_slot)
         {
-            Dock* tmp = dest;
-            while (tmp->next_tab)
+            IM_ASSERT(!dock.parent);
+            if (!dest)
             {
-                tmp = tmp->next_tab;
+                dock.status = Status_Docked;
+                dock.setPosSize(m_workspace_pos, m_workspace_size);
             }
-
-            tmp->next_tab = &dock;
-            dock.prev_tab = tmp;
-            dock.size = tmp->size;
-            dock.pos = tmp->pos;
-            dock.parent = dest->parent;
-            dock.status = Status_Docked;
-        }
-        else if (dock_slot == ImGuiDockSlot_None)
-        {
-            dock.status = Status_Float;
-        }
-        else
-        {
-            Dock* container = (Dock*)MemAlloc(sizeof(Dock));
-            IM_PLACEMENT_NEW(container) Dock();
-            m_docks.push_back(container);
-            container->children[0] = &dest->getFirstTab();
-            container->children[1] = &dock;
-            container->next_tab = NULL;
-            container->prev_tab = NULL;
-            container->parent = dest->parent;
-            container->size = dest->size;
-            container->pos = dest->pos;
-            container->status = Status_Docked;
-            container->label = ImStrdup("");
-
-            if (!dest->parent)
+            else if (dock_slot & ImGuiDockSlot_Tab)
             {
+                Dock* tmp = dest;
+                while (tmp->next_tab)
+                {
+                    tmp = tmp->next_tab;
+                }
+
+                tmp->next_tab = &dock;
+                dock.prev_tab = tmp;
+                dock.size = tmp->size;
+                dock.pos = tmp->pos;
+                dock.parent = dest->parent;
+                dock.status = Status_Docked;
             }
-            else if (&dest->getFirstTab() == dest->parent->children[0])
+            else if (dock_slot & ImGuiDockSlot_None)
             {
-                dest->parent->children[0] = container;
+                dock.status = Status_Float;
             }
             else
             {
-                dest->parent->children[1] = container;
-            }
+                Dock* container = (Dock*)MemAlloc(sizeof(Dock));
+                IM_PLACEMENT_NEW(container) Dock(0);
+                m_docks.push_back(container);
+                container->children[0] = &dest->getFirstTab();
+                container->children[1] = &dock;
+                container->next_tab = NULL;
+                container->prev_tab = NULL;
+                container->parent = dest->parent;
+                container->size = dest->size;
+                container->pos = dest->pos;
+                container->status = Status_Docked;
+                container->label = ImStrdup("");
+
+                if (!dest->parent)
+                {
+                }
+                else if (&dest->getFirstTab() == dest->parent->children[0])
+                {
+                    dest->parent->children[0] = container;
+                }
+                else
+                {
+                    dest->parent->children[1] = container;
+                }
 
-            dest->setParent(container);
-            dock.parent = container;
-            dock.status = Status_Docked;
+                dest->setParent(container);
+                dock.parent = container;
+                dock.status = Status_Docked;
 
-            setDockPosSize(*dest, dock, dock_slot, *container);
+                setDockPosSize(*dest, dock, dock_slot, *container);
+            }
+            dock.setActive();
         }
-        dock.setActive();
-    }
-
-
-    void rootDock(const ImVec2& pos, const ImVec2& size)
-    {
-        Dock* root = getRootDock();
-        if (!root) return;
 
-        ImVec2 min_size = root->getMinSize();
-        ImVec2 requested_size = size;
-        root->setPosSize(pos, ImMax(min_size, requested_size));
-    }
 
+        void rootDock(const ImVec2& pos, const ImVec2& size)
+        {
+            Dock* root = getRootDock();
+            if (!root) return;
 
-    void setDockActive()
-    {
-        IM_ASSERT(m_current);
-        if (m_current) m_current->setActive();
-    }
+            ImVec2 min_size = root->getMinSize();
+            ImVec2 requested_size = size;
+            root->setPosSize(pos, ImMax(min_size, requested_size));
+        }
 
 
-    static ImGuiDockSlot getSlotFromLocationCode(char code)
-    {
-        switch (code)
+        void setDockActive()
         {
-        case '1': return ImGuiDockSlot_Left;
-        case '2': return ImGuiDockSlot_Top;
-        case '3': return ImGuiDockSlot_Bottom;
-        default: return ImGuiDockSlot_Right;
+            IM_ASSERT(m_current);
+            if (m_current) m_current->setActive();
         }
-    }
-
 
-    static char getLocationCode(Dock* dock)
-    {
-        if (!dock) return '0';
 
-        if (dock->parent->isHorizontal())
-        {
-            if (dock->pos.x < dock->parent->children[0]->pos.x) return '1';
-            if (dock->pos.x < dock->parent->children[1]->pos.x) return '1';
-            return '0';
-        }
-        else
+        static ImGuiDockSlot getSlotFromLocationCode(char code)
         {
-            if (dock->pos.y < dock->parent->children[0]->pos.y) return '2';
-            if (dock->pos.y < dock->parent->children[1]->pos.y) return '2';
-            return '3';
+            switch (code)
+            {
+            case '1': return ImGuiDockSlot_Left;
+            case '2': return ImGuiDockSlot_Top;
+            case '3': return ImGuiDockSlot_Bottom;
+            default: return ImGuiDockSlot_Right;
+            }
         }
-    }
 
 
-    void tryDockToStoredLocation(Dock& dock)
-    {
-        if (dock.status == Status_Docked) return;
-        if (dock.location[0] == 0) return;
-
-        Dock* tmp = getRootDock();
-        if (!tmp) return;
-
-        Dock* prev = NULL;
-        char* c = dock.location + strlen(dock.location) - 1;
-        while (c >= dock.location && tmp)
+        static char getLocationCode(Dock* dock)
         {
-            prev = tmp;
-            tmp = *c == getLocationCode(tmp->children[0]) ? tmp->children[0] : tmp->children[1];
-            if(tmp) --c;
+            if (!dock) return '0';
+
+            if (dock->parent->isHorizontal())
+            {
+                if (dock->pos.x < dock->parent->children[0]->pos.x) return '1';
+                if (dock->pos.x < dock->parent->children[1]->pos.x) return '1';
+                return '0';
+            }
+            else
+            {
+                if (dock->pos.y < dock->parent->children[0]->pos.y) return '2';
+                if (dock->pos.y < dock->parent->children[1]->pos.y) return '2';
+                return '3';
+            }
         }
-		if (tmp && tmp->children[0]) tmp = tmp->parent;
-		doDock(dock, tmp ? tmp : prev, tmp && !tmp->children[0] ? ImGuiDockSlot_Tab : getSlotFromLocationCode(*c));
-    }
 
 
-    bool begin(const char* label, bool* opened, ImGuiWindowFlags extra_flags, const ImVec2& default_size)
-    {
-        ImGuiDockSlot next_slot = m_next_dock_slot;
-        m_next_dock_slot = ImGuiDockSlot_Tab;
-	Dock& dock = getDock(label, !opened || *opened, default_size);
-        if (!dock.opened && (!opened || *opened)) tryDockToStoredLocation(dock);
-        dock.last_frame = ImGui::GetFrameCount();
-        if (strcmp(dock.label, label) != 0)
+        void tryDockToStoredLocation(Dock& dock)
         {
-            MemFree(dock.label);
-            dock.label = ImStrdup(label);
+            if (dock.status == Status_Docked) return;
+            if (dock.location[0] == 0) return;
+
+            Dock* tmp = getRootDock();
+            if (!tmp) return;
+
+            Dock* prev = NULL;
+            char* c = dock.location + strlen(dock.location) - 1;
+            while (c >= dock.location && tmp)
+            {
+                prev = tmp;
+                tmp = *c == getLocationCode(tmp->children[0]) ? tmp->children[0] : tmp->children[1];
+                if (tmp) --c;
+            }
+            if (tmp && tmp->children[0]) tmp = tmp->parent;
+            doDock(dock, tmp ? tmp : prev, tmp && !tmp->children[0] ? ImGuiDockSlot_Tab : getSlotFromLocationCode(*c));
         }
 
-        m_end_action = EndAction_None;
 
-        bool prev_opened = dock.opened;
-        bool first = dock.first;
-        if (dock.first && opened) *opened = dock.opened;
-        dock.first = false;
-        if (opened && !*opened)
+        bool begin(const char* label, bool* opened, ImGuiWindowFlags extra_flags, const ImVec2& default_size)
         {
-            if (dock.status != Status_Float)
+            uint32_t next_slot = m_next_dock_slot;
+            m_next_dock_slot = ImGuiDockSlot_Tab;
+            Dock& dock = getDock(label, !opened || *opened, default_size, extra_flags);
+            if (!dock.opened && (!opened || *opened)) tryDockToStoredLocation(dock);
+            dock.last_frame = ImGui::GetFrameCount();
+            if (strcmp(dock.label, label) != 0)
             {
-                fillLocation(dock);
-                doUndock(dock);
-                dock.status = Status_Float;
+                MemFree(dock.label);
+                dock.label = ImStrdup(label);
             }
-            dock.opened = false;
-            return false;
-        }
-        dock.opened = true;
-
-        checkNonexistent();
-        
-        if (first || (prev_opened != dock.opened)) {
-            Dock* root = m_next_parent ? m_next_parent : getRootDock();
-            if (root && (&dock != root) && !dock.parent) {
-                doDock(dock, root, next_slot);
+
+            m_end_action = EndAction_None;
+
+            bool prev_opened = dock.opened;
+            bool first = dock.first;
+            if (dock.first && opened) *opened = dock.opened;
+            dock.first = false;
+            if (opened && !*opened)
+            {
+                if (dock.status != Status_Float)
+                {
+                    fillLocation(dock);
+                    doUndock(dock);
+                    dock.status = Status_Float;
+                }
+                dock.opened = false;
+                return false;
             }
-            m_next_parent = &dock;
-        }
-        
-        m_current = &dock;
-        if (dock.status == Status_Dragged) handleDrag(dock);
+            dock.opened = true;
 
-        bool is_float = dock.status == Status_Float;
+            checkNonexistent();
 
-        if (is_float)
-        {
-            SetNextWindowPos(dock.pos);
-            SetNextWindowSize(dock.size);
-            bool ret = Begin(label,
-                             opened,
-                             dock.size,
-                             -1.0f,
-                             ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_ShowBorders | extra_flags);
-            m_end_action = EndAction_End;
-            dock.pos = GetWindowPos();
-            dock.size = GetWindowSize();
+            if (first || (prev_opened != dock.opened)) {
+                Dock* root = extra_flags & ImGuiDockSlot_FromRoot ? getRootDock() : (m_next_parent ? m_next_parent : getRootDock());
+                if (root && (&dock != root) && !dock.parent) {
+                    doDock(dock, root, next_slot);
+                }
+                m_next_parent = &dock;
+            }
 
-            ImGuiContext& g = *GImGui;
+            m_current = &dock;
+            if (dock.status == Status_Dragged) handleDrag(dock);
+
+            bool is_float = dock.status == Status_Float;
 
-            if (g.ActiveId == GetCurrentWindow()->MoveId && g.IO.MouseDown[0])
+            if (is_float)
             {
-                m_drag_offset = GetMousePos() - dock.pos;
-                doUndock(dock);
-                dock.status = Status_Dragged;
+                SetNextWindowPos(dock.pos);
+                SetNextWindowSize(dock.size);
+                bool ret = Begin(label,
+                    opened,
+                    dock.size,
+                    -1.0f,
+                    ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_ShowBorders | extra_flags);
+                m_end_action = EndAction_End;
+                dock.pos = GetWindowPos();
+                dock.size = GetWindowSize();
+
+                ImGuiContext& g = *GImGui;
+
+                if (g.ActiveId == GetCurrentWindow()->MoveId && g.IO.MouseDown[0])
+                {
+                    m_drag_offset = GetMousePos() - dock.pos;
+                    doUndock(dock);
+                    dock.status = Status_Dragged;
+                }
+                return ret;
             }
-            return ret;
-        }
 
-        if (!dock.active && dock.status != Status_Dragged) return false;
+            if (!dock.active && dock.status != Status_Dragged) return false;
 
-        //beginPanel();
+            //beginPanel();
 
-        m_end_action = EndAction_EndChild;
-        
-        splits();
+            m_end_action = EndAction_EndChild;
 
-        PushStyleColor(ImGuiCol_Border, ImVec4(0, 0, 0, 0));
-        float tabbar_height = GetTextLineHeightWithSpacing();
-        if (tabbar(dock.getFirstTab(), opened != NULL))
-        {
-            fillLocation(dock);
-            *opened = false;
-        }
-        ImVec2 pos = dock.pos;
-        ImVec2 size = dock.size;
-        pos.y += tabbar_height + GetStyle().WindowPadding.y;
-        size.y -= tabbar_height + GetStyle().WindowPadding.y;
+            splits();
 
-        SetCursorScreenPos(pos);
-        ImGuiWindowFlags flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize |
+            PushStyleColor(ImGuiCol_Border, ImVec4(0, 0, 0, 0));
+            float tabbar_height = 0.0f;
+            if (!(extra_flags & ImGuiWindowFlags_NoTitleBar))
+            {
+                tabbar_height = GetTextLineHeightWithSpacing();
+                if (tabbar(dock.getFirstTab(), opened != NULL))
+                {
+                    fillLocation(dock);
+                    *opened = false;
+                }
+            }
+
+            ImVec2 pos = dock.pos;
+            ImVec2 size = dock.size;
+            pos.y += tabbar_height + GetStyle().WindowPadding.y;
+            size.y -= tabbar_height + GetStyle().WindowPadding.y;
+
+            SetCursorScreenPos(pos);
+            ImGuiWindowFlags flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize |
                 ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoCollapse |
                 ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoBringToFrontOnFocus |
                 extra_flags;
-        bool ret = BeginChild(label, size, true, flags);
-        PopStyleColor();
-        
-        return ret;
-    }
+            bool ret = BeginChild(label, size, true, flags);
+            PopStyleColor();
+
+            return ret;
+        }
 
 
-    void end()
-    {
-        m_current = NULL;
-        if (m_end_action != EndAction_None) {
-            if (m_end_action == EndAction_End)
-            {
-                End();
-            }
-            else if (m_end_action == EndAction_EndChild)
-            {
-                PushStyleColor(ImGuiCol_Border, ImVec4(0, 0, 0, 0));
-                EndChild();
-                PopStyleColor();
+        void end()
+        {
+            m_current = NULL;
+            if (m_end_action != EndAction_None) {
+                if (m_end_action == EndAction_End)
+                {
+                    End();
+                }
+                else if (m_end_action == EndAction_EndChild)
+                {
+                    PushStyleColor(ImGuiCol_Border, ImVec4(0, 0, 0, 0));
+                    EndChild();
+                    PopStyleColor();
+                }
+                //endPanel();
             }
-            //endPanel();
         }
-    }
 
 
-    void debugWindow() {
-        //SetNextWindowSize(ImVec2(300, 300));
-        if (Begin("Dock Debug Info")) {
-            for (int i = 0; i < m_docks.size(); ++i) {
-		if (TreeNode(reinterpret_cast<void*> (i), "Dock %d (%p)", i, m_docks[i])) {
-                    Dock &dock = *m_docks[i];
-                    Text("pos=(%.1f %.1f) size=(%.1f %.1f)",
-                         dock.pos.x, dock.pos.y,
-                         dock.size.x, dock.size.y);
-                    Text("parent = %p\n",
-                         dock.parent);
-                    Text("isContainer() == %s\n",
-                         dock.isContainer()?"true":"false");
-                    Text("status = %s\n",
-                         (dock.status == Status_Docked)?"Docked":
-                                                        ((dock.status == Status_Dragged)?"Dragged":
-                                                                                         ((dock.status == Status_Float)?"Float": "?")));
-                    TreePop();
+        void debugWindow() {
+            //SetNextWindowSize(ImVec2(300, 300));
+            if (Begin("Dock Debug Info")) {
+                for (int i = 0; i < m_docks.size(); ++i) {
+                    if (TreeNode(reinterpret_cast<void*> (i), "Dock %d (%p)", i, m_docks[i])) {
+                        Dock &dock = *m_docks[i];
+                        Text("pos=(%.1f %.1f) size=(%.1f %.1f)",
+                            dock.pos.x, dock.pos.y,
+                            dock.size.x, dock.size.y);
+                        Text("parent = %p\n",
+                            dock.parent);
+                        Text("isContainer() == %s\n",
+                            dock.isContainer() ? "true" : "false");
+                        Text("status = %s\n",
+                            (dock.status == Status_Docked) ? "Docked" :
+                            ((dock.status == Status_Dragged) ? "Dragged" :
+                            ((dock.status == Status_Float) ? "Float" : "?")));
+                        TreePop();
+                    }
                 }
+
             }
-            
+            End();
         }
-        End();
-    }
-    
-    int getDockIndex(Dock* dock)
-    {
-        if (!dock) return -1;
 
-        for (int i = 0; i < m_docks.size(); ++i)
+        int getDockIndex(Dock* dock)
         {
-            if (dock == m_docks[i]) return i;
-        }
+            if (!dock) return -1;
 
-        IM_ASSERT(false);
-        return -1;
-    }
-};
+            for (int i = 0; i < m_docks.size(); ++i)
+            {
+                if (dock == m_docks[i]) return i;
+            }
+
+            IM_ASSERT(false);
+            return -1;
+        }
+    };
 
 
-static DockContext g_dock;
+    static ::std::unordered_map<const char*, DockContext> g_dockSpaces;
+    static DockContext* g_dock = nullptr;
 
 
-void ShutdownDock()
-{
-    for (int i = 0; i < g_dock.m_docks.size(); ++i)
+    void ShutdownDock()
     {
-        g_dock.m_docks[i]->~Dock();
-        MemFree(g_dock.m_docks[i]);
+        for (auto &g_dock : g_dockSpaces)
+        {
+            for (auto &dock : g_dock.second.m_docks)
+            {
+                dock->~Dock();
+                MemFree(dock);
+            }
+            g_dock.second.m_docks.clear();
+        }
+        g_dockSpaces.clear();
     }
-    g_dock.m_docks.clear();
-}
 
-void SetNextDock(ImGuiDockSlot slot) {
-    g_dock.m_next_dock_slot = slot;
-}
+    void SetNextDock(uint32_t slot) {
+        g_dock->m_next_dock_slot = slot;
+    }
 
-void BeginDockspace() {
-    ImGuiWindowFlags flags = ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoScrollbar;
-    BeginChild("###workspace", ImVec2(0,0), false, flags);
-    g_dock.m_workspace_pos = GetWindowPos();
-    g_dock.m_workspace_size = GetWindowSize();
-}
+    void BeginDockspace(const char* label, const ImVec2 &workspace, bool showBorder, const ImVec2 &splitSize) {
+        g_dock = &g_dockSpaces[label];
+        ImGuiWindowFlags flags = ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoScrollbar;
+        BeginChild(label ? label : "##workspace", workspace, showBorder, flags);
+        g_dock->m_workspace_pos = GetWindowPos();
+        g_dock->m_workspace_size = GetWindowSize();
+        g_dock->m_splitSize = splitSize;
+    }
 
-void EndDockspace() {
-    EndChild();
-}
+    void EndDockspace() {
+        EndChild();
+        g_dock = nullptr;
+    }
 
-void SetDockActive()
-{
-    g_dock.setDockActive();
-}
+    void SetDockActive()
+    {
+        g_dock->setDockActive();
+    }
 
 
-bool BeginDock(const char* label, bool* opened, ImGuiWindowFlags extra_flags, const ImVec2& default_size)
-{
-    return g_dock.begin(label, opened, extra_flags, default_size);
-}
+    bool BeginDock(const char* label, bool* opened, ImGuiWindowFlags extra_flags, const ImVec2& default_size)
+    {
+        return g_dock->begin(label, opened, extra_flags, default_size);
+    }
 
 
-void EndDock()
-{
-    g_dock.end();
-}
+    void EndDock()
+    {
+        g_dock->end();
+    }
 
-void DockDebugWindow()
-{
-    g_dock.debugWindow();
-}
+    void DockDebugWindow()
+    {
+        g_dock->debugWindow();
+    }
 
 
 #if (defined(IMGUIHELPER_H_) && !defined(NO_IMGUIHELPER_SERIALIZATION))
 #   ifndef NO_IMGUIHELPER_SERIALIZATION_SAVE
-    bool SaveDock(ImGuiHelper::Serializer& s)	{
-	if (!s.isValid()) return false;
-	DockContext& myDock = g_dock;
-	ImVector<DockContext::Dock*>& m_docks = myDock.m_docks;
-
-	int sz = m_docks.size();s.save(&sz,"NumDocks");int id=0;
-	for (int i = 0; i < m_docks.size(); ++i)    {
-	    DockContext::Dock& dock = *m_docks[i];
-	    s.save(&i,"index");
-	    if (dock.label) s.save(dock.label,"label");
-	    s.save(&dock.pos.x,"pos",2);
-	    s.save(&dock.size.x,"size",2);
-	    id = (int) dock.status;s.save(ImGui::FT_ENUM,&id,"status");
-	    s.save(&dock.active,"active");
-	    s.save(&dock.opened,"opened");
-	    id = myDock.getDockIndex(dock.prev_tab);s.save(&id,"prev");
-	    id = myDock.getDockIndex(dock.next_tab);s.save(&id,"next");
-	    id = myDock.getDockIndex(dock.children[0]);s.save(&id,"child0");
-	    id = myDock.getDockIndex(dock.children[1]);s.save(&id,"child1");
-	    id = myDock.getDockIndex(dock.parent);s.save(&id,"parent");
-	}
-	return true;
+    bool SaveDock(ImGuiHelper::Serializer& s) {
+        if (!s.isValid()) return false;
+        DockContext& myDock = g_dock;
+        ImVector<DockContext::Dock*>& m_docks = myDock.m_docks;
+
+        int sz = m_docks.size(); s.save(&sz, "NumDocks"); int id = 0;
+        for (int i = 0; i < m_docks.size(); ++i) {
+            DockContext::Dock& dock = *m_docks[i];
+            s.save(&i, "index");
+            if (dock.label) s.save(dock.label, "label");
+            s.save(&dock.pos.x, "pos", 2);
+            s.save(&dock.size.x, "size", 2);
+            id = (int)dock.status; s.save(ImGui::FT_ENUM, &id, "status");
+            s.save(&dock.active, "active");
+            s.save(&dock.opened, "opened");
+            id = myDock.getDockIndex(dock.prev_tab); s.save(&id, "prev");
+            id = myDock.getDockIndex(dock.next_tab); s.save(&id, "next");
+            id = myDock.getDockIndex(dock.children[0]); s.save(&id, "child0");
+            id = myDock.getDockIndex(dock.children[1]); s.save(&id, "child1");
+            id = myDock.getDockIndex(dock.parent); s.save(&id, "parent");
+        }
+        return true;
     }
-    bool SaveDock(const char* filename)   {ImGuiHelper::Serializer s(filename);return SaveDock(s);}
+    bool SaveDock(const char* filename) { ImGuiHelper::Serializer s(filename); return SaveDock(s); }
 #   endif //NO_IMGUIHELPER_SERIALIZATION_SAVE
 #   ifndef NO_IMGUIHELPER_SERIALIZATION_LOAD
     struct DockParser {
-	DockContext* myDock;int numDocks;int curIndex;
-	inline static DockContext::Dock* getDockByIndex(DockContext* myDock,int idx) { return (idx < 0) ? NULL : myDock->m_docks[idx];}
-	DockParser(DockContext* _myDock) : myDock(_myDock),numDocks(0),curIndex(-1) {IM_ASSERT(myDock);}
-	static bool Parse(ImGuiHelper::FieldType /*ft*/,int /*numArrayElements*/,void* pValue,const char* name,void* userPtr) {
-	    DockParser& P = *((DockParser*) userPtr);
-	    DockContext& myDock = *P.myDock;
-	    ImVector<DockContext::Dock*>& m_docks = myDock.m_docks;
-	    const int* pValueInt = (const int*) pValue;
-	    if (strcmp(name,"NumDocks")==0) {
-		IM_ASSERT(P.curIndex==-1);
-		P.numDocks = *pValueInt;
-		IM_ASSERT(m_docks.size()==0);
-		m_docks.reserve(P.numDocks);
-		for (int i=0;i<P.numDocks;i++)  {
-		    DockContext::Dock* new_dock = (DockContext::Dock*)ImGui::MemAlloc(sizeof(DockContext::Dock));
-		    m_docks.push_back(IM_PLACEMENT_NEW(new_dock) DockContext::Dock());
-		}
-		P.curIndex=0;
-	    }
-	    else if (P.curIndex<0 || P.curIndex>P.numDocks) {IM_ASSERT(true);return true;}
-	    else if (strcmp(name,"index")==0)  {
-		P.curIndex = *pValueInt;
-		IM_ASSERT(P.curIndex>=0 && P.curIndex<m_docks.size());
-		m_docks[P.curIndex]->last_frame = 0;
-		m_docks[P.curIndex]->invalid_frames = 0;
-	    }
-	    else if (strcmp(name,"label")==0) {
-		    m_docks[P.curIndex]->label = ImStrdup((const char*) pValue);
-		    m_docks[P.curIndex]->id = ImHash(m_docks[P.curIndex]->label, 0);
-	    }
-	    else if (strcmp(name,"pos")==0) m_docks[P.curIndex]->pos = *((ImVec2*) pValue);
-	    else if (strcmp(name,"size")==0) m_docks[P.curIndex]->size = *((ImVec2*) pValue);
-	    else if (strcmp(name,"status")==0) m_docks[P.curIndex]->status = (DockContext::Status_) (*pValueInt);
-	    else if (strcmp(name,"active")==0) m_docks[P.curIndex]->active = (*pValueInt) ? true : false;
-	    else if (strcmp(name,"opened")==0) m_docks[P.curIndex]->opened = (*pValueInt) ? true : false;
-
-	    else if (strcmp(name,"prev")==0) m_docks[P.curIndex]->prev_tab = getDockByIndex(&myDock,*pValueInt);
-	    else if (strcmp(name,"next")==0) m_docks[P.curIndex]->next_tab = getDockByIndex(&myDock,*pValueInt);
-	    else if (strcmp(name,"child0")==0) m_docks[P.curIndex]->children[0] = getDockByIndex(&myDock,*pValueInt);
-	    else if (strcmp(name,"child1")==0) m_docks[P.curIndex]->children[1] = getDockByIndex(&myDock,*pValueInt);
-	    else if (strcmp(name,"parent")==0) {
-		m_docks[P.curIndex]->parent = getDockByIndex(&myDock,*pValueInt);
-		if (P.curIndex+1==P.numDocks) {
-		    return true;
-		}
-	    }
-
-	    return false;
-	}
+        DockContext* myDock; int numDocks; int curIndex;
+        inline static DockContext::Dock* getDockByIndex(DockContext* myDock, int idx) { return (idx < 0) ? NULL : myDock->m_docks[idx]; }
+        DockParser(DockContext* _myDock) : myDock(_myDock), numDocks(0), curIndex(-1) { IM_ASSERT(myDock); }
+        static bool Parse(ImGuiHelper::FieldType /*ft*/, int /*numArrayElements*/, void* pValue, const char* name, void* userPtr) {
+            DockParser& P = *((DockParser*)userPtr);
+            DockContext& myDock = *P.myDock;
+            ImVector<DockContext::Dock*>& m_docks = myDock.m_docks;
+            const int* pValueInt = (const int*)pValue;
+            if (strcmp(name, "NumDocks") == 0) {
+                IM_ASSERT(P.curIndex == -1);
+                P.numDocks = *pValueInt;
+                IM_ASSERT(m_docks.size() == 0);
+                m_docks.reserve(P.numDocks);
+                for (int i = 0; i < P.numDocks; i++) {
+                    DockContext::Dock* new_dock = (DockContext::Dock*)ImGui::MemAlloc(sizeof(DockContext::Dock));
+                    m_docks.push_back(IM_PLACEMENT_NEW(new_dock) DockContext::Dock());
+                }
+                P.curIndex = 0;
+            }
+            else if (P.curIndex<0 || P.curIndex>P.numDocks) { IM_ASSERT(true); return true; }
+            else if (strcmp(name, "index") == 0) {
+                P.curIndex = *pValueInt;
+                IM_ASSERT(P.curIndex >= 0 && P.curIndex < m_docks.size());
+                m_docks[P.curIndex]->last_frame = 0;
+                m_docks[P.curIndex]->invalid_frames = 0;
+            }
+            else if (strcmp(name, "label") == 0) {
+                m_docks[P.curIndex]->label = ImStrdup((const char*)pValue);
+                m_docks[P.curIndex]->id = ImHash(m_docks[P.curIndex]->label, 0);
+            }
+            else if (strcmp(name, "pos") == 0) m_docks[P.curIndex]->pos = *((ImVec2*)pValue);
+            else if (strcmp(name, "size") == 0) m_docks[P.curIndex]->size = *((ImVec2*)pValue);
+            else if (strcmp(name, "status") == 0) m_docks[P.curIndex]->status = (DockContext::Status_) (*pValueInt);
+            else if (strcmp(name, "active") == 0) m_docks[P.curIndex]->active = (*pValueInt) ? true : false;
+            else if (strcmp(name, "opened") == 0) m_docks[P.curIndex]->opened = (*pValueInt) ? true : false;
+
+            else if (strcmp(name, "prev") == 0) m_docks[P.curIndex]->prev_tab = getDockByIndex(&myDock, *pValueInt);
+            else if (strcmp(name, "next") == 0) m_docks[P.curIndex]->next_tab = getDockByIndex(&myDock, *pValueInt);
+            else if (strcmp(name, "child0") == 0) m_docks[P.curIndex]->children[0] = getDockByIndex(&myDock, *pValueInt);
+            else if (strcmp(name, "child1") == 0) m_docks[P.curIndex]->children[1] = getDockByIndex(&myDock, *pValueInt);
+            else if (strcmp(name, "parent") == 0) {
+                m_docks[P.curIndex]->parent = getDockByIndex(&myDock, *pValueInt);
+                if (P.curIndex + 1 == P.numDocks) {
+                    return true;
+                }
+            }
+
+            return false;
+        }
     };
-    bool LoadDock(ImGuiHelper::Deserializer& d,const char ** pOptionalBufferStart)  {
-	if (!d.isValid()) return false;
-	const char* amount = pOptionalBufferStart ? (*pOptionalBufferStart) : 0;
-	DockContext& myDock = g_dock;
-	ImVector<DockContext::Dock*>& m_docks = myDock.m_docks;
-	// clear
-	for (int i = 0; i < m_docks.size(); ++i)    {
-	    m_docks[i]->~Dock();
-	    ImGui::MemFree(m_docks[i]);
-	}
-	m_docks.clear();
-	myDock.m_current = myDock.m_next_parent = NULL;
-
-	// parse
-	DockParser parser(&myDock);
-	amount = d.parse(&DockParser::Parse,(void*)&parser,amount);
-	if (pOptionalBufferStart) *pOptionalBufferStart = amount;
-	return true;
+    bool LoadDock(ImGuiHelper::Deserializer& d, const char ** pOptionalBufferStart) {
+        if (!d.isValid()) return false;
+        const char* amount = pOptionalBufferStart ? (*pOptionalBufferStart) : 0;
+        DockContext& myDock = g_dock;
+        ImVector<DockContext::Dock*>& m_docks = myDock.m_docks;
+        // clear
+        for (int i = 0; i < m_docks.size(); ++i) {
+            m_docks[i]->~Dock();
+            ImGui::MemFree(m_docks[i]);
+        }
+        m_docks.clear();
+        myDock.m_current = myDock.m_next_parent = NULL;
+
+        // parse
+        DockParser parser(&myDock);
+        amount = d.parse(&DockParser::Parse, (void*)&parser, amount);
+        if (pOptionalBufferStart) *pOptionalBufferStart = amount;
+        return true;
     }
-    bool LoadDock(const char* filename)  {ImGuiHelper::Deserializer d(filename);return LoadDock(d);}
+    bool LoadDock(const char* filename) { ImGuiHelper::Deserializer d(filename); return LoadDock(d); }
 #   endif //NO_IMGUIHELPER_SERIALIZATION_LOAD
 #endif //(defined(IMGUIHELPER_H_) && !defined(NO_IMGUIHELPER_SERIALIZATION))
 
diff --git a/addons/imguidock/imguidock.h b/addons/imguidock/imguidock.h
index 5404993..12495cc 100644
--- a/addons/imguidock/imguidock.h
+++ b/addons/imguidock/imguidock.h
@@ -74,37 +74,37 @@ SOFTWARE.
 #ifndef IMGUI_API
 #include <imgui.h>
 #endif //IMGUI_API
- 
+
 typedef enum ImGuiDockSlot {
-    ImGuiDockSlot_Left=0,
-    ImGuiDockSlot_Right,
-    ImGuiDockSlot_Top,
-    ImGuiDockSlot_Bottom,
-    ImGuiDockSlot_Tab,
-
-    ImGuiDockSlot_Float,
-    ImGuiDockSlot_None
+    ImGuiDockSlot_None = 0,
+    ImGuiDockSlot_Left = 1 << 0,
+    ImGuiDockSlot_Right = 1 << 1,
+    ImGuiDockSlot_Top = 1 << 2,
+    ImGuiDockSlot_Bottom = 1 << 3,
+    ImGuiDockSlot_Tab = 1 << 4,
+    ImGuiDockSlot_Float = 1 << 5,
+    ImGuiDockSlot_FromRoot = 1 << 6,
 } ImGuiDockSlot;
 
-namespace ImGui{
+namespace ImGui {
 
-IMGUI_API void BeginDockspace();
-IMGUI_API void EndDockspace();
-IMGUI_API void ShutdownDock();
-IMGUI_API void SetNextDock(ImGuiDockSlot slot);
-IMGUI_API bool BeginDock(const char* label, bool* opened = NULL, ImGuiWindowFlags extra_flags = 0, const ImVec2& default_size = ImVec2(-1, -1));
-IMGUI_API void EndDock();
-IMGUI_API void SetDockActive();
-IMGUI_API void DockDebugWindow();
+    IMGUI_API void BeginDockspace(const char* label = nullptr, const ImVec2 &workspace = ImVec2(0, 0), bool showBorder = false, const ImVec2 &splitSize = ImVec2(3.0f, 3.0f));
+    IMGUI_API void EndDockspace();
+    IMGUI_API void ShutdownDock();
+    IMGUI_API void SetNextDock(uint32_t slot);
+    IMGUI_API bool BeginDock(const char* label, bool* opened = NULL, ImGuiWindowFlags extra_flags = 0, const ImVec2& default_size = ImVec2(-1, -1));
+    IMGUI_API void EndDock();
+    IMGUI_API void SetDockActive();
+    IMGUI_API void DockDebugWindow();
 
-// Ported from the original "Lua binding" code
+    // Ported from the original "Lua binding" code
 #if (defined(IMGUIHELPER_H_) && !defined(NO_IMGUIHELPER_SERIALIZATION))
 #   ifndef NO_IMGUIHELPER_SERIALIZATION_SAVE
     IMGUI_API bool SaveDock(ImGuiHelper::Serializer& s);
     IMGUI_API bool SaveDock(const char* filename);
 #   endif //NO_IMGUIHELPER_SERIALIZATION_SAVE
 #   ifndef NO_IMGUIHELPER_SERIALIZATION_LOAD
-    IMGUI_API bool LoadDock(ImGuiHelper::Deserializer& d,const char ** pOptionalBufferStart=NULL);
+    IMGUI_API bool LoadDock(ImGuiHelper::Deserializer& d, const char ** pOptionalBufferStart = NULL);
     IMGUI_API bool LoadDock(const char* filename);
 #   endif //NO_IMGUIHELPER_SERIALIZATION_LOAD
 #endif //(defined(IMGUIHELPER_H_) && !defined(NO_IMGUIHELPER_SERIALIZATION))
diff --git a/addons/imguifilesystem/imguifilesystem.cpp b/addons/imguifilesystem/imguifilesystem.cpp
index 99fde8f..682fcf7 100644
--- a/addons/imguifilesystem/imguifilesystem.cpp
+++ b/addons/imguifilesystem/imguifilesystem.cpp
@@ -1431,27 +1431,30 @@ struct ImGuiFsDrawIconStruct {
 
     return cnt;
     }
-    ImGuiFsDrawIconStruct() {
-    v.reserve(1024);
-    vStarters.reserve(400);vStartersLengths.reserve(400);
-    vStartersCounts.reserve(400);
-
-    add("bin");                                     // ICON_FA_FILE_O
-    add("h;hpp;hh;hxx;inl");                        // ICON_FA_H_SQUARE
-    add("cpp;c;cxx;cc");                            // ICON_FA_PLUS_SQUARE
-    add("jpg;jpeg;png;bmp;ico;gif;tif;tiff;tga");   // ICON_FA_FILE_IMAGE_O
-    add("pdf");                                     // ICON_FA_FILE_PDF_O
-    add("doc;docx;odt;ott;uot");                    // ICON_FA_FILE_WORD_O
-    add("txt;setting;settings;layout;ini;md;sh;bat");// ICON_FA_FILE_TEXT_O
-    add("db;sql;sqlite");                           // ICON_FA_DATABASE
-    add("ods;ots;uos;xlsx;xls");                    // ICON_FA_FILE_EXCEL_O
-    add("odp;otp;uop;pptx;ppt");                    // ICON_FA_FILE_POWERPOINT_O
-    add("7z;zip;bz2;gz;lz;lzma;ar;rar");            // ICON_FA_FILE_ARCHIVE_O
-    add("mp3;wav;ogg;spx;opus;mid;mod;flac");       // ICON_FA_FILE_AUDIO_O
-    add("mp4;flv;avi;ogv;theora;mkv;webm;mpg");     // ICON_FA_FILE_VIDEO_O
-    add("xml");                                     // ICON_FA_FILE_CODE_O
-    add("htm;html");                                // ICON_FA_FILE_CODE_O
-
+    ImGuiFsDrawIconStruct(bool allocate = true)
+    {
+        if (allocate)
+        {
+            v.reserve(1024);
+            vStarters.reserve(400); vStartersLengths.reserve(400);
+            vStartersCounts.reserve(400);
+
+            add("bin");                                     // ICON_FA_FILE_O
+            add("h;hpp;hh;hxx;inl");                        // ICON_FA_H_SQUARE
+            add("cpp;c;cxx;cc");                            // ICON_FA_PLUS_SQUARE
+            add("jpg;jpeg;png;bmp;ico;gif;tif;tiff;tga");   // ICON_FA_FILE_IMAGE_O
+            add("pdf");                                     // ICON_FA_FILE_PDF_O
+            add("doc;docx;odt;ott;uot");                    // ICON_FA_FILE_WORD_O
+            add("txt;setting;settings;layout;ini;md;sh;bat");// ICON_FA_FILE_TEXT_O
+            add("db;sql;sqlite");                           // ICON_FA_DATABASE
+            add("ods;ots;uos;xlsx;xls");                    // ICON_FA_FILE_EXCEL_O
+            add("odp;otp;uop;pptx;ppt");                    // ICON_FA_FILE_POWERPOINT_O
+            add("7z;zip;bz2;gz;lz;lzma;ar;rar");            // ICON_FA_FILE_ARCHIVE_O
+            add("mp3;wav;ogg;spx;opus;mid;mod;flac");       // ICON_FA_FILE_AUDIO_O
+            add("mp4;flv;avi;ogv;theora;mkv;webm;mpg");     // ICON_FA_FILE_VIDEO_O
+            add("xml");                                     // ICON_FA_FILE_CODE_O
+            add("htm;html");                                // ICON_FA_FILE_CODE_O
+        }
     }
     int getExtensionType(const char* ext,bool caseSensitiveMatch=false) const {
         if (!ext) return -1;
@@ -1482,7 +1485,7 @@ struct ImGuiFsDrawIconStruct {
     return drawIcon(extType,pOptionalColorOverride);
     }
 };
-static ImGuiFsDrawIconStruct MyImGuiFsDrawIconStruct;
+static ImGuiFsDrawIconStruct MyImGuiFsDrawIconStruct(false);
 #ifndef IMGUIFS_NO_EXTRA_METHODS
 int FileGetExtensionType(const char* path) {
     return MyImGuiFsDrawIconStruct.getExtensionType(strrchr(path,'.'));
diff --git a/addons/imguinodegrapheditor/imguinodegrapheditor.h b/addons/imguinodegrapheditor/imguinodegrapheditor.h
index 4357df2..8d82d20 100644
--- a/addons/imguinodegrapheditor/imguinodegrapheditor.h
+++ b/addons/imguinodegrapheditor/imguinodegrapheditor.h
@@ -353,7 +353,7 @@ struct NodeLink
         OutputNode = output_node; OutputSlot = output_slot;
     }
 
-    friend struct NodeGraphEditor;
+    friend class NodeGraphEditor;
 };
 
 class NodeGraphEditor
diff --git a/addons/imguipanelmanager/imguipanelmanager.cpp b/addons/imguipanelmanager/imguipanelmanager.cpp
index a66f5da..a73f95f 100644
--- a/addons/imguipanelmanager/imguipanelmanager.cpp
+++ b/addons/imguipanelmanager/imguipanelmanager.cpp
@@ -862,7 +862,7 @@ void ImGui::PanelManager::Pane::AssociatedWindow::draw(const ImGui::PanelManager
     const bool togglable = button && button->isToggleButton;
     const bool togglableAndVisible = togglable && button->isDown;
     const bool selected = (this==pane.getSelectedWindow());
-    const bool hovered = !selected && (pane.allowHoverOnTogglableWindows ? !togglableAndVisible : !togglable) && (this==pane.getHoverWindow() || persistHoverFocus);
+    const bool hovered = pane.previewOnHover ? (!selected && (pane.allowHoverOnTogglableWindows ? !togglableAndVisible : !togglable) && (this == pane.getHoverWindow() || persistHoverFocus)) : false;
     if (!togglableAndVisible && !selected && !hovered) return;
 
     if (dirty)  {
diff --git a/addons/imguipanelmanager/imguipanelmanager.h b/addons/imguipanelmanager/imguipanelmanager.h
index 5895092..e5d477e 100644
--- a/addons/imguipanelmanager/imguipanelmanager.h
+++ b/addons/imguipanelmanager/imguipanelmanager.h
@@ -71,10 +71,11 @@ struct PanelManager {
         Position pos;
         bool visible;
         bool allowHoverOnTogglableWindows;
+        bool previewOnHover;
         mutable float hoverReleaseTimer;
         mutable int hoverReleaseIndex;
         Pane(Position _pos,const char* name)
-        : bar(name),pos(_pos),visible(true),allowHoverOnTogglableWindows(false),hoverReleaseTimer(-1),hoverReleaseIndex(-1)
+        : bar(name),pos(_pos),visible(true),allowHoverOnTogglableWindows(false),previewOnHover(true),hoverReleaseTimer(-1),hoverReleaseIndex(-1)
         {}
         ~Pane() {clear();}
         void clear() {
diff --git a/addons/imguivariouscontrols/imguivariouscontrols.cpp b/addons/imguivariouscontrols/imguivariouscontrols.cpp
index a3643c6..428dc65 100644
--- a/addons/imguivariouscontrols/imguivariouscontrols.cpp
+++ b/addons/imguivariouscontrols/imguivariouscontrols.cpp
@@ -80,7 +80,9 @@ static bool CheckButton(const char* label,bool* pvalue,bool useSmallButton,float
     return rv;
 }
 bool CheckButton(const char* label,bool* pvalue) {return CheckButton(label,pvalue,false);}
+bool CheckButton(const char* label,bool value) {return CheckButton(label,&value,false);}
 bool SmallCheckButton(const char* label,bool* pvalue) {return CheckButton(label,pvalue,true);}
+bool SmallCheckButton(const char* label,bool value) {return CheckButton(label,&value,true);}
 
 float ProgressBar(const char *optionalPrefixText, float value, const float minValue, const float maxValue, const char *format, const ImVec2 &sizeOfBarWithoutTextInPixels, const ImVec4 &colorLeft, const ImVec4 &colorRight, const ImVec4 &colorBorder)    {
     if (value<minValue) value=minValue;
diff --git a/addons/imguivariouscontrols/imguivariouscontrols.h b/addons/imguivariouscontrols/imguivariouscontrols.h
index 6eddd37..e46379a 100644
--- a/addons/imguivariouscontrols/imguivariouscontrols.h
+++ b/addons/imguivariouscontrols/imguivariouscontrols.h
@@ -40,7 +40,9 @@ IMGUI_API bool IsItemJustReleased();
 #endif //IMGUIHELPER_H_
 
 IMGUI_API bool CheckButton(const char* label,bool* pvalue);
+IMGUI_API bool CheckButton(const char* label,bool value);
 IMGUI_API bool SmallCheckButton(const char* label,bool* pvalue);
+IMGUI_API bool SmallCheckButton(const char* label,bool value);
 
 // Please note that you can tweak the "format" argument if you want to add a prefix (or a suffix) piece of text to the text that appears at the right of the bar.
 // returns the value "fraction" in 0.f-1.f.
diff --git a/imgui.cpp b/imgui.cpp
index 7ca66c7..fa8b4ac 100644
--- a/imgui.cpp
+++ b/imgui.cpp
@@ -621,8 +621,6 @@
 #endif
 
 #include "imgui.h"
-#define IMGUI_DEFINE_MATH_OPERATORS
-#define IMGUI_DEFINE_PLACEMENT_NEW
 #include "imgui_internal.h"
 
 #include <ctype.h>      // toupper, isprint
@@ -667,7 +665,6 @@
 
 static void             LogRenderedText(const ImVec2& ref_pos, const char* text, const char* text_end = NULL);
 
-static void             PushMultiItemsWidths(int components, float w_full = 0.0f);
 static float            GetDraggedColumnOffset(int column_index);
 
 static bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true);
@@ -4612,7 +4609,7 @@ void ImGui::PushItemWidth(float item_width)
     window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);
 }
 
-static void PushMultiItemsWidths(int components, float w_full)
+void ImGui::PushMultiItemsWidths(int components, float w_full)
 {
     ImGuiWindow* window = ImGui::GetCurrentWindow();
     const ImGuiStyle& style = GImGui->Style;
@@ -4775,30 +4772,32 @@ static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)
     return &GStyleVarInfo[idx];
 }
 
-void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
+float ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
 {
     const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
     if (var_info->Type == ImGuiDataType_Float)
     {
-        float* pvar = (float*)var_info->GetVarPtr();
+        float* pvar = (float*)var_info->GetVarPtr(), ovar = *pvar;
         GImGui->StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
         *pvar = val;
-        return;
+        return ovar;
     }
     IM_ASSERT(0); // Called function with wrong-type? Variable is not a float.
+    return 0.0f;
 }
 
-void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
+ImVec2 ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
 {
     const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
     if (var_info->Type == ImGuiDataType_Float2)
     {
-        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr();
+        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(), ovar = *pvar;
         GImGui->StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
         *pvar = val;
-        return;
+        return ovar;
     }
     IM_ASSERT(0); // Called function with wrong-type? Variable is not a ImVec2.
+    return ImVec2(0.0f, 0.0f);
 }
 
 void ImGui::PopStyleVar(int count)
@@ -6723,9 +6722,57 @@ bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float
 
 bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)
 {
-    float v_deg = (*v_rad) * 360.0f / (2*IM_PI);
+    float v_deg = (*v_rad) * 360.0f / (2 * IM_PI);
     bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, "%.0f deg", 1.0f);
-    *v_rad = v_deg * (2*IM_PI) / 360.0f;
+    *v_rad = v_deg * (2 * IM_PI) / 360.0f;
+    return value_changed;
+}
+
+bool ImGui::SliderAngle2(const char* label, float v_rad[2], float v_degrees_min, float v_degrees_max)
+{
+    float v_deg[]
+    {
+        v_rad[0] * 360.0f / (2 * IM_PI),
+        v_rad[1] * 360.0f / (2 * IM_PI),
+    };
+
+    bool value_changed = SliderFloat2(label, v_deg, v_degrees_min, v_degrees_max, "%.0f deg", 1.0f);
+    v_rad[0] = v_deg[0] * (2 * IM_PI) / 360.0f;
+    v_rad[1] = v_deg[1] * (2 * IM_PI) / 360.0f;
+    return value_changed;
+}
+
+bool ImGui::SliderAngle3(const char* label, float v_rad[3], float v_degrees_min, float v_degrees_max)
+{
+    float v_deg[]
+    {
+        v_rad[0] * 360.0f / (2 * IM_PI),
+        v_rad[1] * 360.0f / (2 * IM_PI),
+        v_rad[2] * 360.0f / (2 * IM_PI),
+    };
+
+    bool value_changed = SliderFloat3(label, v_deg, v_degrees_min, v_degrees_max, "%.0f deg", 1.0f);
+    v_rad[0] = v_deg[0] * (2 * IM_PI) / 360.0f;
+    v_rad[1] = v_deg[1] * (2 * IM_PI) / 360.0f;
+    v_rad[2] = v_deg[2] * (2 * IM_PI) / 360.0f;
+    return value_changed;
+}
+
+bool ImGui::SliderAngle4(const char* label, float v_rad[4], float v_degrees_min, float v_degrees_max)
+{
+    float v_deg[]
+    {
+        v_rad[0] * 360.0f / (2 * IM_PI),
+        v_rad[1] * 360.0f / (2 * IM_PI),
+        v_rad[2] * 360.0f / (2 * IM_PI),
+        v_rad[3] * 360.0f / (2 * IM_PI),
+    };
+
+    bool value_changed = SliderFloat4(label, v_deg, v_degrees_min, v_degrees_max, "%.0f deg", 1.0f);
+    v_rad[0] = v_deg[0] * (2 * IM_PI) / 360.0f;
+    v_rad[1] = v_deg[1] * (2 * IM_PI) / 360.0f;
+    v_rad[2] = v_deg[2] * (2 * IM_PI) / 360.0f;
+    v_rad[3] = v_deg[3] * (2 * IM_PI) / 360.0f;
     return value_changed;
 }
 
diff --git a/imgui.h b/imgui.h
index 2b37c5b..f9fd023 100644
--- a/imgui.h
+++ b/imgui.h
@@ -8,6 +8,8 @@
 
 #pragma once
 
+#include <Windows.h>
+
 #if !defined(IMGUI_DISABLE_INCLUDE_IMCONFIG_H) || defined(IMGUI_INCLUDE_IMCONFIG_H)
 #include "imconfig.h"       // User-editable configuration file
 #endif
@@ -182,8 +184,8 @@ namespace ImGui
     IMGUI_API void          PopFont();
     IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);
     IMGUI_API void          PopStyleColor(int count = 1);
-    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);
-    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
+    IMGUI_API float         PushStyleVar(ImGuiStyleVar idx, float val);
+    IMGUI_API ImVec2        PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
     IMGUI_API void          PopStyleVar(int count = 1);
     IMGUI_API ImFont*       GetFont();                                                          // get current font
     IMGUI_API float         GetFontSize();                                                      // get current font size (= height in pixels) of current font with current scale applied
@@ -192,6 +194,7 @@ namespace ImGui
     IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                     // retrieve given color with style alpha applied
 
     // Parameters stacks (current window)
+    IMGUI_API void          PushMultiItemsWidths(int components, float w_full = 0.0f);
     IMGUI_API void          PushItemWidth(float item_width);                                    // width of items for the common item+label case, pixels. 0.0f = default to ~2/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)
     IMGUI_API void          PopItemWidth();
     IMGUI_API float         CalcItemWidth();                                                    // width of item given pushed settings and current cursor position
@@ -316,6 +319,9 @@ namespace ImGui
     IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
     IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
     IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);
+    IMGUI_API bool          SliderAngle2(const char* label, float v_rad[2], float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);
+    IMGUI_API bool          SliderAngle3(const char* label, float v_rad[3], float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);
+    IMGUI_API bool          SliderAngle4(const char* label, float v_rad[4], float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);
     IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format = "%.0f");
     IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format = "%.0f");
     IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format = "%.0f");
diff --git a/imgui_draw.cpp b/imgui_draw.cpp
index fa6838a..04cf6d3 100644
--- a/imgui_draw.cpp
+++ b/imgui_draw.cpp
@@ -13,8 +13,6 @@
 #endif
 
 #include "imgui.h"
-#define IMGUI_DEFINE_MATH_OPERATORS
-#define IMGUI_DEFINE_PLACEMENT_NEW
 #include "imgui_internal.h"
 
 #include <stdio.h>      // vsnprintf, sscanf, printf
